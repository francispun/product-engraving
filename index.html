<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
  <title>Knife Engraving Customiser</title>
  <link rel="icon" type="image/x-icon" href="./favicon.ico">

  <!-- fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Lobster&family=Roboto&display=swap" rel="stylesheet">

  <style>
    :root {
      --accent: #d00024;
      --gray: #888;
      --bg: #fafafa;
      --border: #ddd;
      --pad: 1rem;
      --radius: .5rem;
      --thumb-w: 80px;
    }
    * { box-sizing: border-box; margin: 0; }
    body {
      font-family: Roboto, Arial, sans-serif;
      background: var(--bg);
      color: #222;
    }
    h1,h2,h3 { text-align: center; margin: 1rem 0; }
    .container {
      max-width: 1200px; margin: auto; padding: var(--pad);
    }
    .section {
      background: #fff; border: 1px solid var(--border);
      border-radius: var(--radius); padding: var(--pad);
      margin-bottom: var(--pad);
    }
    /* STEP 1: vertical list */
    #product-picker {
      display: flex; flex-direction: column; gap: .5rem;
    }
    .product-option {
      display: flex; align-items: center; gap: .75rem;
    }
    .product-option img {
      width: var(--thumb-w); height: auto;
      border: 1px solid var(--border); border-radius: var(--radius);
    }
    .controls {
      display: flex; flex-wrap: wrap; gap: 1rem; align-items: center;
    }
    .controls label { font-size: .9rem; }
    button {
      background: var(--accent); color: #fff; border: none;
      padding: .6rem 1rem; border-radius: var(--radius);
      cursor: pointer; font-weight: 600;
    }
    button[disabled] {
      opacity: .4; cursor: not-allowed;
    }
    .canvas-wrapper {
      position: relative; width: 100%;
      border: 1px solid var(--border); border-radius: var(--radius);
      background: #eaeaea; touch-action: none; margin: auto;
    }
    canvas {
      display: block; touch-action: none;
    }
    .loadingOverlay {
      position: absolute; inset: 0;
      background: rgba(255,255,255,0.85);
      display: flex; align-items: center; justify-content: center;
      font-size: 1.2rem; color: #555;
      visibility: hidden; z-index: 10;
    }
    .bbox {
      position: absolute; border: 1px dashed #000;
      pointer-events: none; display: none;
    }
    .handle {
      position: absolute; width: 10px; height: 10px;
      background: #fff; border: 1px solid #000;
      pointer-events: auto;
    }
    .handle[data-handle="nw"] { top: -5px; left: -5px; cursor: nwse-resize; }
    .handle[data-handle="ne"] { top: -5px; right: -5px; cursor: nesw-resize; }
    .handle[data-handle="sw"] { bottom: -5px; left: -5px; cursor: nesw-resize; }
    .handle[data-handle="se"] { bottom: -5px; right: -5px; cursor: nwse-resize; }
    .group-controls {
      display: flex; gap: 1rem; justify-content: flex-end; margin-bottom: 1rem;
    }
    #backBtn { background: var(--gray); margin-bottom: 1rem; }
  </style>
</head>
<body>
  <h1>Knife Engraving Customiser</h1>
  <div class="container">

    <!-- STEP 1: SELECT KNIVES -->
    <div id="selectionSection" class="section">
      <h2>1. Select your knives</h2>
      <div id="product-picker">
        <label class="product-option">
          <input type="checkbox" data-id="chef" data-name="Chef Knife" data-src="chef.jpg" data-size="big">
          <img src="chef-thumb.jpg" alt="Chef"><span>Chef Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" data-id="santoku" data-name="Santoku Knife" data-src="santoku.jpg" data-size="big">
          <img src="santoku-thumb.jpg" alt="Santoku"><span>Santoku Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" data-id="bread" data-name="Bread Knife" data-src="bread.jpg" data-size="big">
          <img src="bread-thumb.jpg" alt="Bread"><span>Bread Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" data-id="chopper" data-name="Chopper Knife" data-src="chopper.jpg" data-size="big">
          <img src="chopper-thumb.jpg" alt="Chopper"><span>Chopper Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" data-id="utility" data-name="Utility Knife" data-src="utility.jpg" data-size="small">
          <img src="utility-thumb.jpg" alt="Utility"><span>Utility Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" data-id="paring" data-name="Paring Knife" data-src="paring.jpg" data-size="small">
          <img src="paring-thumb.jpg" alt="Paring"><span>Paring Knife</span>
        </label>
      </div>
      <div style="text-align:center; margin-top:1rem;">
        <button id="toCustomizeBtn" disabled>Next: Customize</button>
      </div>
    </div>

    <!-- EDITOR -->
    <div id="editorSection" style="display:none;">
      <button id="backBtn">‚Üê Back to selection</button>

      <div id="bigSection" class="section">
        <h2>Large Knives Customization</h2>
        <div class="group-controls">
          <button id="alignBig">Align to Last</button>
          <button id="matchBig">Match Font Size</button>
        </div>
        <div id="bigKnifeSections" class="container"></div>
      </div>

      <div id="smallSection" class="section">
        <h2>Small Knives Customization</h2>
        <div class="group-controls">
          <button id="alignSmall">Align to Last</button>
          <button id="matchSmall">Match Font Size</button>
        </div>
        <div id="smallKnifeSections" class="container"></div>
      </div>

      <div style="text-align:center; margin:1rem 0;">
        <button id="downloadZipBtn">Generate & Download ZIP</button>
      </div>
    </div>

  </div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.7.1/dist/jszip.min.js"></script>
  <script>
  (function(){
    const baseFont = 150;
    let selected = [];
    let lastActive = null;

    // ELEMENTS
    const toCustomizeBtn = document.getElementById('toCustomizeBtn');
    const backBtn        = document.getElementById('backBtn');
    const selectionSec   = document.getElementById('selectionSection');
    const editorSec      = document.getElementById('editorSection');
    const bigContainer   = document.getElementById('bigKnifeSections');
    const smallContainer = document.getElementById('smallKnifeSections');
    const alignBigBtn    = document.getElementById('alignBig');
    const matchBigBtn    = document.getElementById('matchBig');
    const alignSmallBtn  = document.getElementById('alignSmall');
    const matchSmallBtn  = document.getElementById('matchSmall');
    const downloadZipBtn = document.getElementById('downloadZipBtn');

    // Load image helper
    function loadImage(src){
      return new Promise(res=>{
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = ()=>res(img);
        img.src = src;
      });
    }

    // Enable Next
    document.querySelectorAll('#product-picker input[type=checkbox]').forEach(chk=>{
      chk.addEventListener('change', ()=>{
        toCustomizeBtn.disabled = ![...document.querySelectorAll('#product-picker input[type=checkbox]')]
          .some(c=>c.checked);
      });
    });

    toCustomizeBtn.addEventListener('click', ()=>{
      // build selected array
      selected = [...document.querySelectorAll('#product-picker input[type=checkbox]:checked')]
        .map((chk,i) => ({
          id:      chk.dataset.id,
          name:    chk.dataset.name,
          src:     chk.dataset.src,
          size:    chk.dataset.size,    // "big" or "small"
          text:    '',
          font:    'Montserrat',
          textScale: 1,
          baseDims: {w:0,h:0},
          pos:     {x:0,y:0},
          pointers:{}, pinch:false,
          _elements: {},  // placeholders for runtime references
        }));
      selectionSec.style.display = 'none';
      editorSec.style.display    = '';
      renderEditors();
    });

    backBtn.addEventListener('click', ()=>{
      editorSec.style.display    = 'none';
      selectionSec.style.display = '';
      bigContainer.innerHTML = '';
      smallContainer.innerHTML = '';
      selected = [];
    });

    function renderEditors(){
      bigContainer.innerHTML   = '';
      smallContainer.innerHTML = '';
      // partition
      const bigs   = selected.filter(k=>k.size==='big');
      const smalls = selected.filter(k=>k.size==='small');
      bigs.forEach((kn,i)=>makeKnifeSection(kn, i, bigContainer, bigs));
      smalls.forEach((kn,i)=>makeKnifeSection(kn, i, smallContainer, smalls));
    }

    function makeKnifeSection(kn, index, container, group){
      // section wrapper
      const sec = document.createElement('div');
      sec.className = 'section';
      // controls
      let html = `<h3>${kn.name}</h3>
        <div class="controls" style="margin-bottom:1rem; align-items:center;">`;
      // text input
      html += `<label>Text:</label>
        <input type="text" class="txtInput" style="min-width:200px;" value="">`;
      // if not first, add "same as previous" checkbox
      if(index > 0){
        html += `<label style="margin-left:.5rem;">
            <input type="checkbox" class="sameText"> Same as previous
          </label>`;
      }
      // font select
      html += `<label style="margin-left:1rem;">Font:</label>
        <select class="fontSelect">
          <option value="Montserrat">Montserrat</option>
          <option value="Roboto">Roboto</option>
          <option value="Lobster">Lobster</option>
          <option value="'Times New Roman',serif">Times New Roman</option>
          <option value="Courier New">Courier New</option>
          <option value="Arial">Arial</option>
        </select>
      </div>
      <div class="canvas-wrapper" id="wrap-${kn.id}">
        <canvas id="view-${kn.id}"></canvas>
        <div id="loading-${kn.id}" class="loadingOverlay">Loading‚Ä¶</div>
        <div id="bbox-${kn.id}" class="bbox">
          <div class="handle" data-handle="nw"></div>
          <div class="handle" data-handle="ne"></div>
          <div class="handle" data-handle="sw"></div>
          <div class="handle" data-handle="se"></div>
        </div>
      </div>`;
      sec.innerHTML = html;
      container.appendChild(sec);

      // store elements
      const txtInput = sec.querySelector('.txtInput');
      const fontSel  = sec.querySelector('.fontSelect');
      const sameChk  = sec.querySelector('.sameText');
      kn._elements = { txtInput, fontSel, sameChk };

      initCanvas(kn, group);
      // local text binding
      txtInput.addEventListener('input', e=>{
        kn.text = e.target.value;
        kn.baseDims = measure(kn);
        kn.textScale = 1;
        centerText(kn);
        kn.draw();
        lastActive = kn;
      });
      fontSel.addEventListener('input', e=>{
        kn.font = e.target.value;
        kn.baseDims = measure(kn);
        kn.textScale = 1;
        centerText(kn);
        kn.draw();
        lastActive = kn;
      });
      if(sameChk){
        sameChk.addEventListener('change', e=>{
          if(e.target.checked){
            const prev = group[index-1];
            kn.text = prev.text;
            kn._elements.txtInput.value = kn.text;
            kn.baseDims = measure(kn);
            kn.textScale = 1;
            centerText(kn);
            kn.draw();
          }
        });
      }
    }

    function initCanvas(kn, group){
      const wrap    = document.getElementById(`wrap-${kn.id}`);
      const view    = document.getElementById(`view-${kn.id}`);
      const overlay = document.getElementById(`loading-${kn.id}`);
      const bbox    = document.getElementById(`bbox-${kn.id}`);
      const handles = bbox.querySelectorAll('.handle');
      const vCtx    = view.getContext('2d');
      const full    = document.createElement('canvas');
      const fCtx    = full.getContext('2d');

      Object.assign(kn, { _view:view, _vCtx:vCtx, _full:full, _fCtx:fCtx,
                         _overlay:overlay, _bbox:bbox, _handles:handles });

      function showOverlay(on){
        overlay.style.visibility = on ? 'visible' : 'hidden';
      }
      function fit(){
        const w = wrap.clientWidth;
        const scale = kn._img.naturalWidth ? w / kn._img.naturalWidth : 1;
        view.width  = kn._img.naturalWidth * scale;
        view.height = kn._img.naturalHeight * scale;
        full.width  = kn._img.naturalWidth;
        full.height = kn._img.naturalHeight;
      }
      function toFull(cx,cy){
        const r = view.getBoundingClientRect();
        return {
          x: (cx - r.left) * (full.width / r.width),
          y: (cy - r.top ) * (full.height/ r.height)
        };
      }
      function hitTest(x,y){
        return x>=kn.pos.x && x<=kn.pos.x+kn.baseDims.w*kn.textScale
            && y>=kn.pos.y && y<=kn.pos.y+kn.baseDims.h*kn.textScale;
      }
      function draw(){
        // full
        fCtx.clearRect(0,0,full.width,full.height);
        fCtx.drawImage(kn._img,0,0);
        fCtx.font = `${baseFont*kn.textScale}px ${kn.font}`;
        fCtx.fillStyle='#000'; fCtx.textBaseline='top';
        fCtx.fillText(kn.text, kn.pos.x, kn.pos.y);
        // preview
        const s = view.width/full.width;
        vCtx.setTransform(s,0,0,s,0,0);
        vCtx.clearRect(0,0,full.width,full.height);
        vCtx.drawImage(kn._img,0,0);
        vCtx.font = `${baseFont*kn.textScale}px ${kn.font}`;
        vCtx.fillStyle='#000'; vCtx.textBaseline='top';
        vCtx.fillText(kn.text, kn.pos.x, kn.pos.y);
        vCtx.setTransform(1,0,0,1,0,0);
        // bbox
        const dx = view.width/full.width, dy=view.height/full.height;
        if(kn.text){
          bbox.style.display='block';
          bbox.style.width  = (kn.baseDims.w*kn.textScale*dx)+'px';
          bbox.style.height = (kn.baseDims.h*kn.textScale*dy)+'px';
          bbox.style.left   = (kn.pos.x*dx)+'px';
          bbox.style.top    = (kn.pos.y*dy)+'px';
        } else {
          bbox.style.display='none';
        }
      }
      kn.draw = draw;

      // center defaults
      function centerText(k){
        k.pos.x = full.width/2 - k.baseDims.w/2;
        k.pos.y = full.height/2 - k.baseDims.h/2;
      }
      function measure(k){
        const ctx = k._fCtx;
        ctx.font = `${baseFont}px ${k.font}`;
        const w = ctx.measureText(k.text).width;
        return { w, h: baseFont };
      }

      // load image
      showOverlay(true);
      loadImage(kn.src).then(img=>{
        kn._img = img;
        fit();
        kn.baseDims = measure(kn);
        kn.textScale = 1;
        centerText(kn);
        draw();
        showOverlay(false);
      });

      // track pointer interactions
      let dragging=false, dragStart={}, resizing=false, resizeStart={};

      view.addEventListener('pointerdown', e=>{
        const f = toFull(e.clientX,e.clientY);
        if(!hitTest(f.x,f.y)||resizing||kn.pinch) return;
        dragging=true;
        dragStart = { id:e.pointerId, dx:f.x-kn.pos.x, dy:f.y-kn.pos.y };
        e.preventDefault();
      });
      window.addEventListener('pointermove', e=>{
        if(!dragging||e.pointerId!==dragStart.id) return;
        const f = toFull(e.clientX,e.clientY);
        kn.pos.x = f.x - dragStart.dx;
        kn.pos.y = f.y - dragStart.dy;
        draw();
      });
      ['pointerup','pointercancel'].forEach(evt=>
        window.addEventListener(evt,e=>{
          if(e.pointerId===dragStart.id) dragging=false;
          if(e.pointerId===dragStart.id) lastActive = kn;
        })
      );

      // handles resize
      handles.forEach(h=>{
        h.addEventListener('pointerdown', e=>{
          e.stopPropagation();
          resizing=true;
          const box = bbox.getBoundingClientRect();
          const center = toFull(box.left+box.width/2, box.top+box.height/2);
          const p0 = toFull(e.clientX,e.clientY);
          resizeStart = {
            id: e.pointerId,
            cx: center.x, cy: center.y,
            scale: kn.textScale,
            d0: Math.hypot(p0.x-center.x, p0.y-center.y)
          };
        });
      });
      window.addEventListener('pointermove', e=>{
        if(!resizing||e.pointerId!==resizeStart.id) return;
        const p = toFull(e.clientX,e.clientY);
        const d = Math.hypot(p.x-resizeStart.cx, p.y-resizeStart.cy);
        kn.textScale = resizeStart.scale * (d/resizeStart.d0);
        kn.pos.x = resizeStart.cx - (kn.baseDims.w*kn.textScale)/2;
        kn.pos.y = resizeStart.cy - (kn.baseDims.h*kn.textScale)/2;
        draw();
      });
      ['pointerup','pointercancel'].forEach(evt=>
        window.addEventListener(evt,e=>{
          if(e.pointerId===resizeStart.id) resizing=false;
          if(e.pointerId===resizeStart.id) lastActive = kn;
        })
      );

      // pinch zoom
      view.addEventListener('pointerdown', e=>{
        kn.pointers[e.pointerId] = { x:e.clientX, y:e.clientY };
        if(Object.keys(kn.pointers).length===2 && !dragging && !resizing){
          kn.pinch = true;
          const [a,b] = Object.values(kn.pointers);
          const fA = toFull(a.x,a.y), fB = toFull(b.x,b.y);
          kn.pinchStart = {
            scale: kn.textScale,
            cx: (fA.x+fB.x)/2, cy: (fA.y+fB.y)/2,
            d0: Math.hypot(fA.x-fB.x, fA.y-fB.y)
          };
        }
      });
      view.addEventListener('pointermove', e=>{
        if(!kn.pinch||!(e.pointerId in kn.pointers)) return;
        kn.pointers[e.pointerId] = { x:e.clientX, y:e.clientY };
        const [a,b] = Object.values(kn.pointers);
        const fA = toFull(a.x,a.y), fB = toFull(b.x,b.y);
        const d1 = Math.hypot(fA.x-fB.x,fA.y-fB.y);
        kn.textScale = kn.pinchStart.scale * (d1/kn.pinchStart.d0);
        kn.pos.x = kn.pinchStart.cx - (kn.baseDims.w*kn.textScale)/2;
        kn.pos.y = kn.pinchStart.cy - (kn.baseDims.h*kn.textScale)/2;
        draw();
      });
      ['pointerup','pointercancel'].forEach(evt=>
        view.addEventListener(evt,e=>{
          delete kn.pointers[e.pointerId];
          if(Object.keys(kn.pointers).length<2) {
            kn.pinch=false;
            lastActive = kn;
          }
        })
      );
    }

    // Align and Match handlers
    function alignGroup(size){
      if(!lastActive || lastActive.size!==size) return;
      const grp = selected.filter(k=>k.size===size);
      grp.forEach(k=>{ if(k!==lastActive){ k.pos.x = lastActive.pos.x; k.draw(); } });
    }
    function matchSizeGroup(size){
      if(!lastActive || lastActive.size!==size) return;
      const grp = selected.filter(k=>k.size===size);
      grp.forEach(k=>{
        if(k!==lastActive){
          k.textScale = lastActive.textScale;
          k.draw();
        }
      });
    }
    alignBigBtn.addEventListener('click', ()=>alignGroup('big'));
    matchBigBtn.addEventListener('click', ()=>matchSizeGroup('big'));
    alignSmallBtn.addEventListener('click', ()=>alignGroup('small'));
    matchSmallBtn.addEventListener('click', ()=>matchSizeGroup('small'));

    // ZIP download
    downloadZipBtn.addEventListener('click', ()=>{
      const zip = new JSZip();
      const knivesFolder = zip.folder('knives');
      const textOnlyFold = zip.folder('text-only');
      Promise.all(selected.map(kn=>{
        // knife image
        return new Promise(res=>{
          kn._full.toBlob(blob=>{
            knivesFolder.file(`${kn.id}.png`, blob);
            // text-only
            const t = document.createElement('canvas');
            t.width = kn._full.width; t.height = kn._full.height;
            const tCtx = t.getContext('2d');
            tCtx.font = `${baseFont*kn.textScale}px ${kn.font}`;
            tCtx.fillStyle = '#000'; tCtx.textBaseline='top';
            tCtx.fillText(kn.text, kn.pos.x, kn.pos.y);
            t.toBlob(tb=>{
              textOnlyFold.file(`${kn.id}-text.png`, tb);
              res();
            });
          });
        });
      })).then(()=>{
        zip.generateAsync({type:'blob'}).then(content=>{
          const url = URL.createObjectURL(content);
          const a = document.createElement('a');
          a.href = url; a.download = 'engravings.zip';
          document.body.appendChild(a); a.click();
          setTimeout(()=>{
            URL.revokeObjectURL(url); a.remove();
          },100);
        });
      });
    });

  })();
  </script>
</body>
</html>
