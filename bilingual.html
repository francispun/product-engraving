<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
  <title>Knife Engraving Customiser</title>
  <link rel="icon" type="image/x-icon" href="./favicon.ico">

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto&family=Lobster&family=Chocolate+Classical+Sans&family=LXGW+WenKai+Mono+TC&family=Noto+Sans+HK&family=Noto+Serif+TC&display=swap" rel="stylesheet">

  <!-- Material Symbols -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

  <!-- JSZip for ZIP download -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <style>
  :root {
    --accent: #d00024;
    --gray: #888;
    --bg: #fafafa;
    --border: #ddd;
    --pad: 1rem;
    --radius: .5rem;
  }
  * {
    box-sizing: border-box;
    margin: 0;
  }
  body {
    font-family: Roboto, 'Noto Sans HK', Arial, sans-serif;
    background: #474a51;
    color: #ffffff;
    padding-bottom: 60px;
  }
  h1, h2, h3 {
    text-align: center;
    margin: 1rem 0;
  }
  h3 {
    margin-bottom: 1rem;
  }
  .container {
    max-width: 1200px;
    margin: auto;
    padding: var(--pad);
    display: flex;
    flex-direction: column;
    gap: var(--pad);
  }
  .page {
    display: none;
  }
  .page.active {
    display: block;
  }
  .section {
    background: #fff;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: var(--pad);
  }
  #product-picker {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: .75rem;
  }
  .product-option {
    position: relative;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    min-height: 140px;
    padding: 0.5rem;
  }
  .product-option input {
    position: absolute;
    inset: 0;
    opacity: 0;
    cursor: pointer;
  }
  .product-option img {
    width: 100%;
    max-height: 140px;
    object-fit: contain;
    border: 2px solid transparent;
    border-radius: var(--radius);
    display: block;
  }
  .product-option input:checked+img {
    border-color: var(--accent);
  }
  .product-option span {
    display: block;
    font-size: .9rem;
    margin-top: .25rem;
    color: #4c4c4c;
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    align-items: center;
  }
  .controls label {
    font-size: .9rem;
    margin-right: .25rem;
  }
  .controls input[type="text"] {
    width: 250px;
    height: 33px;
    padding: .5rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
  }
  .controls select {
    height: 33px;
    border-radius: 7px;
  }
  .canvas-wrapper {
    position: relative;
    width: 100%;
    max-width: 1168px;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: #eaeaea;
    touch-action: none;
    margin: auto;
    overflow: hidden; /* Prevent canvas overflow */
  }
  canvas {
    display: block;
    touch-action: none;
    max-width: 100%; /* Ensure canvas fits container */
    height: auto; /* Maintain aspect ratio */
  }
  .loading-overlay {
    position: absolute;
    inset: 0;
    background: rgba(255, 255, 255, 0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    color: #555;
    visibility: hidden;
    z-index: 10;
  }
  .bbox {
    position: absolute;
    border: 1px dashed #000;
    pointer-events: none;
    display: none;
    z-index: 30;
  }
  .handle {
    position: absolute;
    width: 10px;
    height: 10px;
    background: #fff;
    border: 1px solid #000;
    pointer-events: auto;
    z-index: 31;
  }
  .handle[data-handle="nw"] {
    top: -5px;
    left: -5px;
    cursor: nwse-resize;
  }
  .handle[data-handle="ne"] {
    top: -5px;
    right: -5px;
    cursor: nesw-resize;
  }
  .handle[data-handle="sw"] {
    bottom: -5px;
    left: -5px;
    cursor: nesw-resize;
  }
  .handle[data-handle="se"] {
    bottom: -5px;
    right: -5px;
    cursor: nwse-resize;
  }
  button {
    background: var(--accent);
    color: #fff;
    border: none;
    padding: .6rem;
    border-radius: var(--radius);
    cursor: pointer;
    font-weight: 600;
    font-size: 1rem;
    margin: 0 .25rem;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  button[disabled] {
    opacity: .4;
    cursor: not-allowed;
  }
  button.off {
    background: var(--gray);
  }
  .material-symbols-outlined {
    font-size: 24px;
    vertical-align: middle;
  }
  #edit-zone .material-symbols-outlined {
    font-variation-settings: 'FILL' 1;
  }
  .same-content {
    display: block;
    margin-top: .5rem;
  }
  .knife-section {
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: var(--pad);
    margin-bottom: 1rem;
  }
  .navigation {
    position: fixed;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    background: rgb(51, 57, 68);
    padding: 1rem;
    display: flex;
    justify-content: center;
    gap: 0.6rem;
    z-index: 100;
    flex-wrap: nowrap;
    overflow-x: auto;
    white-space: nowrap;
    margin: 20px 0;
    width: auto;
    max-width: 510px;
    border-radius: 18px;
    box-shadow: 0px 0px 5px #2f3138;
  }
  .preview-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
  .preview-item {
    text-align: center;
  }
  .preview-item img {
    width: 100%;
    max-width: 100%;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    cursor: pointer;
  }
  .preview-item span {
    display: block;
    font-size: .9rem;
    margin-top: .5rem;
  }
  .preview-description {
    text-align: center;
    font-size: .9rem;
    color: #666;
    margin-bottom: 1rem;
  }
  .modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 1000;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: .5rem;
  }
  .modal img {
    max-width: 90%;
    max-height: 85%;
    border-radius: var(--radius);
  }
  .modal span {
    color: #fff;
    font-size: 1rem;
  }
  #lang-toggle {
    display: none;
    margin: 0 auto 1rem;
    padding: .5rem 1rem;
    text-align: center;
  }
  #page-1.active #lang-toggle {
    display: block;
  }
  .knife-section p {
    margin: 11px 0px;
    color: #a5a5a5 !important;
  }
  div#page-1 {
    color: #4c4c4c;
  }
  @media (max-width: 600px) {
    .controls {
      flex-direction: column;
      align-items: flex-start;
      display: block;
    }
    .controls div {
      margin: 10px 0px;
    }
    .controls input[type="text"] {
      width: 100%;
      max-width: 250px;
    }
    button {
      padding: .5rem;
      font-size: .9rem;
    }
    .material-symbols-outlined {
      font-size: 20px;
    }
    #lang-toggle {
      margin: 0 auto .5rem;
      padding: .4rem .8rem;
      font-size: .9rem;
    }
    .modal span {
      font-size: .9rem;
    }
    .product-option {
      min-height: 180px;
    }
    .product-option img {
      max-height: 120px;
      transform: scale(1.5);
    }
    #product-picker {
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }
  }
</style>
</head>
<body>
  <h1 id="title">Knife Engraving Customiser</h1>
  <h3 id="subtitle">by <img src="kool-logo.png" alt="logo" style="width:50px;vertical-align:bottom;"></h3>
  <div class="container">
    <!-- Page 1: Knife Selection -->
    <div id="page-1" class="page section active">
      <button id="lang-toggle">中文</button>
      <h2 data-i18n="chooseKnives">Choose your knives</h2>
      <div id="product-picker">
        <label class="product-option">
          <input type="checkbox" name="product" value="chef.jpg" data-thumb="chef-thumb.jpg" data-name="chef">
          <img src="chef-thumb.jpg" alt="Chef knife">
          <span data-i18n="chefKnife">Chef Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="santoku.jpg" data-thumb="santoku-thumb.jpg" data-name="santoku">
          <img src="santoku-thumb.jpg" alt="Santoku knife">
          <span data-i18n="santokuKnife">Santoku Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="bread.jpg" data-thumb="bread-thumb.jpg" data-name="bread">
          <img src="bread-thumb.jpg" alt="Bread knife">
          <span data-i18n="breadKnife">Bread Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="chopper.jpg" data-thumb="chopper-thumb.jpg" data-name="chopper">
          <img src="chopper-thumb.jpg" alt="Chopper knife">
          <span data-i18n="chopperKnife">Chopper Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="utility.jpg" data-thumb="utility-thumb.jpg" data-name="utility">
          <img src="utility-thumb.jpg" alt="Utility knife">
          <span data-i18n="utilityKnife">Utility Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="paring.jpg" data-thumb="paring-thumb.jpg" data-name="paring">
          <img src="paring-thumb.jpg" alt="Paring knife">
          <span data-i18n="paringKnife">Paring Knife</span>
        </label>
      </div>
      <div class="navigation">
        <button id="next-1"><span class="material-symbols-outlined">arrow_forward_ios</span></button>
      </div>
    </div>

    <!-- Page 2: Big Knives Customization -->
    <div id="page-2" class="page">
      <div id="big-knife-content"></div>
      <div class="navigation">
        <button id="back-2"><span class="material-symbols-outlined">arrow_back_ios_new</span></button>
        <button id="edit-zone" class="off"><span class="material-symbols-outlined">vignette</span></button>
        <button id="resize-controls"><span class="material-symbols-outlined">format_shapes</span></button>
        <button id="sync-fonts"><span class="material-symbols-outlined">format_size</span></button>
        <button id="auto-align"><span class="material-symbols-outlined">recenter</span></button>
        <button id="next-2"><span class="material-symbols-outlined">arrow_forward_ios</span></button>
      </div>
    </div>

    <!-- Page 3: Small Knives Customization -->
    <div id="page-3" class="page">
      <div id="small-knife-content"></div>
      <div class="navigation">
        <button id="back-3"><span class="material-symbols-outlined">arrow_back_ios_new</span></button>
        <button id="edit-zone" class="off"><span class="material-symbols-outlined">vignette</span></button>
        <button id="resize-controls"><span class="material-symbols-outlined">format_shapes</span></button>
        <button id="sync-fonts"><span class="material-symbols-outlined">format_size</span></button>
        <button id="auto-align"><span class="material-symbols-outlined">recenter</span></button>
        <button id="next-3"><span class="material-symbols-outlined">arrow_forward_ios</span></button>
      </div>
    </div>

    <!-- Page 4: Preview and Download -->
    <div id="page-4" class="page section">
      <h2 data-i18n="previewAllKnives">Preview All Knives</h2>
      <div class="preview-description" data-i18n="previewDescription">Click any image to enlarge</div>
      <div id="preview-content" class="preview-list"></div>
      <div class="navigation">
        <button id="back-4"><span class="material-symbols-outlined">arrow_back_ios_new</span></button>
        <button id="download-all"><span class="material-symbols-outlined">download_2</span></button>
      </div>
    </div>

    <!-- Modal for Enlarged Image -->
    <div id="modal" class="modal">
      <img id="modal-image" src="" alt="Enlarged preview">
      <span data-i18n="modalClose">Click anywhere to close</span>
    </div>
  </div>

  <script>
    /* TRANSLATIONS */
const translations = {
  en: {
    title: "Knife Engraving Customiser",
    subtitle: "by",
    subtitleAfter: "",
    chooseKnives: "Choose your knives",
    next: "Next",
    back: "Back",
    preview: "Preview",
    previewAllKnives: "Preview All Knives",
    previewDescription: "Click any image to enlarge",
    download: "Download",
    chefKnife: "Chef Knife",
    santokuKnife: "Santoku Knife",
    breadKnife: "Bread Knife",
    chopperKnife: "Chopper Knife",
    utilityKnife: "Utility Knife",
    paringKnife: "Paring Knife",
    textLabel: "Text:",
    textPlaceholder: "Enter engraving",
    fontLabel: "Font:",
    sameContentLabel: "Same text for all",
    instructions: "• Drag text to move.<br>• Drag a corner to scale (desktop).<br>• Pinch to zoom and move text (mobile).",
    editZone: "Edit Zone",
    resizeControls: "Resize Controls",
    syncFonts: "Sync Fonts",
    autoAlignment: "Auto Align",
    loading: "Loading…",
    knife: "Knife",
    english: "English",
    chinese: "Chinese",
    modalClose: "Click anywhere to close"
  },
  "zh-hk": {
    title: "刀具刻字定制器",
    subtitle: "由",
    subtitleAfter: "提供",
    chooseKnives: "選擇您的刀具",
    next: "下一步",
    back: "返回",
    preview: "預覽",
    previewAllKnives: "預覽所有刀具",
    previewDescription: "點擊任何圖片放大",
    download: "下載",
    chefKnife: "主廚刀",
    santokuKnife: "三德刀",
    breadKnife: "麵包刀",
    chopperKnife: "砍刀",
    utilityKnife: "多用途刀",
    paringKnife: "削皮刀",
    textLabel: "文字：",
    textPlaceholder: "輸入刻字",
    fontLabel: "字體：",
    sameContentLabel: "所有刀具使用相同文字",
    instructions: "• 拖動文字以移動。<br>• 拖動角落以縮放（桌面）。<br>• 捏合以縮放和移動文字（手機）。",
    editZone: "編輯區域",
    resizeControls: "調整控制",
    syncFonts: "同步字體",
    autoAlignment: "自動對齊",
    loading: "載入中…",
    knife: "刀",
    english: "英文",
    chinese: "中文",
    modalClose: "點擊任意位置關閉"
  }
};

/* LANGUAGE TOGGLE */
let currentLang = 'en';

function updateLanguage(lang) {
  currentLang = lang;
  document.documentElement.lang = lang;
  const langToggleBtn = document.getElementById('lang-toggle');
  if (langToggleBtn) {
    langToggleBtn.textContent = lang === 'en' ? translations['zh-hk'].chinese : translations.en.english;
  }

  document.getElementById('title').textContent = translations[lang].title;
  const subtitle = document.getElementById('subtitle');
  subtitle.innerHTML = `${translations[lang].subtitle} <img src="kool-logo.png" alt="logo" style="width:50px;vertical-align:bottom;"> ${translations[lang].subtitleAfter}`;
  document.querySelectorAll('[data-i18n]').forEach(el => {
    const key = el.getAttribute('data-i18n');
    if (translations[lang][key]) {
      if (el.tagName === 'INPUT' && el.type === 'text') {
        el.placeholder = translations[lang][key];
      } else if (el.id !== 'back-2' && el.id !== 'back-3' && el.id !== 'back-4' && 
                 el.id !== 'edit-zone' && el.id !== 'resize-controls' && 
                 el.id !== 'sync-fonts' && el.id !== 'auto-align' && 
                 el.id !== 'next-1' && el.id !== 'next-2' && el.id !== 'next-3' && 
                 el.id !== 'download-all') {
        el.textContent = translations[lang][key];
      }
    }
  });

  bigKnifeContent.innerHTML = '';
  smallKnifeContent.innerHTML = '';
  const selectedKnives = Object.keys(state);
  selectedKnives.forEach(knife => {
    createCanvasSection(knife);
    initializeKnife(knife);
  });

  if (pages[4].classList.contains('active')) {
    generatePreviews();
  }
}

document.addEventListener('click', e => {
  if (e.target.id === 'lang-toggle' || e.target.closest('#lang-toggle')) {
    console.log('Language toggle clicked');
    updateLanguage(currentLang === 'en' ? 'zh-hk' : 'en');
  }
});

/* STATE */
const knives = {
  big: ['santoku', 'chef', 'bread', 'chopper'],
  small: ['utility', 'paring']
};
const state = {};
let sameContent = true;
let sharedText = '';
let firstSelectedKnife = null;
let lastAdjusted = { big: null, small: null };
let syncFonts = true; // Default to ON
let showEditZone = false;
let showResizeControls = true; // Default to ON
let autoAlignBig = true; // Default to ON
let autoAlignSmall = true; // Default to ON
let isNavigating = false;
let lastToggleTime = 0;
let lastBigKnifeFont = currentLang === 'zh-hk' ? "'Noto Sans HK',sans-serif" : "Roboto";
const toggleDebounce = 200; // ms
const dragThrottle = 16; // ms (approx 60fps)
const scaleDebounce = 50; // ms for scaling performance

/* ELEMENTS */
const pages = {
  1: document.getElementById('page-1'),
  2: document.getElementById('page-2'),
  3: document.getElementById('page-3'),
  4: document.getElementById('page-4')
};
const productPicker = document.getElementById('product-picker');
const bigKnifeContent = document.getElementById('big-knife-content');
const smallKnifeContent = document.getElementById('small-knife-content');
const previewContent = document.getElementById('preview-content');
const next1Btn = document.getElementById('next-1');
const back2Btn = document.getElementById('back-2');
const next2Btn = document.getElementById('next-2');
const back3Btn = document.getElementById('back-3');
const next3Btn = document.getElementById('next-3');
const back4Btn = document.getElementById('back-4');
const downloadBtn = document.getElementById('download-all');
const modal = document.getElementById('modal');
const modalImage = document.getElementById('modal-image');

/* HELPERS */
function loadImage(src) {
  return new Promise((resolve, reject) => {
    const i = new Image();
    i.crossOrigin = 'anonymous';
    i.onload = () => resolve(i);
    i.onerror = () => reject(new Error(`Failed to load image: ${src}`));
    i.src = src;
  });
}

function fitInBox(canvas, img, wrapper) {
  const wrapW = wrapper.clientWidth; // Container width
  const devicePixelRatio = window.devicePixelRatio || 1; // High-DPI support
  const aspectRatio = img.naturalWidth / img.naturalHeight;
  const canvasW = wrapW; // Match container width
  const canvasH = canvasW / aspectRatio; // Preserve image aspect ratio

  // Set pixel dimensions for high resolution
  canvas.width = canvasW * devicePixelRatio;
  canvas.height = canvasH * devicePixelRatio;

  // Set display dimensions to fit container
  canvas.style.width = `${canvasW}px`;
  canvas.style.height = `${canvasH}px`;

  return canvasW / img.naturalWidth; // Return scale for coordinate calculations
}

function measureText(ctx, text, fontSize, font) {
  ctx.font = `${fontSize}px ${font}`;
  return { w: ctx.measureText(text).width, h: fontSize };
}

function toFullCoords(canvas, wrapper, cx, cy) {
  const r = canvas.getBoundingClientRect();
  const devicePixelRatio = window.devicePixelRatio || 1;
  return {
    x: (cx - r.left) * (wrapper.full.width / r.width) * devicePixelRatio,
    y: (cy - r.top) * (wrapper.full.height / r.height) * devicePixelRatio
  };
}

function hitTest(fx, fy, pos, dims, scale, isRightAligned) {
  const x = isRightAligned ? pos.x - dims.w * scale : pos.x;
  return fx >= x && fx <= x + dims.w * scale &&
         fy >= pos.y && fy <= pos.y + dims.h * scale;
}

function hasBigKnives(selected) {
  return selected.some(input => knives.big.includes(input.dataset.name));
}

function hasSmallKnives(selected) {
  return selected.some(input => knives.small.includes(input.dataset.name));
}

function switchPage(from, to) {
  if (isNavigating) return;
  isNavigating = true;
  pages[from].classList.remove('active');
  pages[to].classList.add('active');
  setTimeout(() => { isNavigating = false; }, 100);
}

function createCanvasSection(knife) {
  const showSameContent = knife === firstSelectedKnife;
  const section = document.createElement('div');
  section.className = 'knife-section';
  section.innerHTML = `
    <h3 data-i18n="${knife}Knife">${translations[currentLang][`${knife}Knife`]}</h3>
    <div class="controls">
      <div>
        <label for="text-${knife}" data-i18n="textLabel">${translations[currentLang].textLabel}</label>
        <input type="text" id="text-${knife}" placeholder="${translations[currentLang].textPlaceholder}">
      </div>
      <div>
        <label for="font-${knife}" data-i18n="fontLabel">${translations[currentLang].fontLabel}</label>
        <select id="font-${knife}" ${currentLang === 'zh-hk' ? 'data-default="Noto Sans HK"' : ''}>
          <optgroup label="${translations[currentLang].english}">
            <option value="Roboto">Roboto</option>
            <option value="Montserrat">Montserrat</option>
            <option value="Lobster">Lobster</option>
            <option value="'Times New Roman',serif">Times New Roman</option>
            <option value="'Courier New',monospace">Courier New</option>
            <option value="Arial,sans-serif">Arial</option>
          </optgroup>
          <optgroup label="${translations[currentLang].chinese}">
            <option value="'Chocolate Classical Sans',sans-serif">朱古力黑體</option>
            <option value="'LXGW WenKai Mono TC',monospace">霞鶩文楷</option>
            <option value="'Noto Sans HK',sans-serif">思源黑體</option>
            <option value="'Noto Serif TC',serif">思源宋體</option>
          </optgroup>
        </select>
      </div>
    </div>
    ${showSameContent ? `
      <div class="same-content">
        <input type="checkbox" id="same-content-${knife}" ${sameContent ? 'checked' : ''}>
        <label for="same-content-${knife}" data-i18n="sameContentLabel">${translations[currentLang].sameContentLabel}</label>
      </div>
    ` : ''}
    <p style="font-size:.8rem;color:#666;margin-top:.5rem;" data-i18n="instructions">
      ${translations[currentLang].instructions}
    </p>
    <div class="canvas-wrapper" id="wrapper-${knife}">
      <canvas id="canvas-${knife}"></canvas>
      <div class="loading-overlay" id="overlay-${knife}" data-i18n="loading">${translations[currentLang].loading}</div>
      <div class="bbox" id="bbox-${knife}">
        <div class="handle" data-handle="nw"></div>
        <div class="handle" data-handle="ne"></div>
        <div class="handle" data-handle="sw"></div>
        <div class="handle" data-handle="se"></div>
      </div>
    </div>
  `;
  if (knives.big.includes(knife)) {
    bigKnifeContent.appendChild(section);
  } else {
    smallKnifeContent.appendChild(section);
  }

  state[knife] = {
    img: null,
    overlay: null,
    baseFont: knives.big.includes(knife) ? 150 : 100,
    textScale: 1,
    baseDims: { w: 0, h: 0 },
    pos: { x: 0, y: 0 },
    boxVisible: showResizeControls,
    dragging: false,
    dragStart: {},
    resizing: false,
    resizeStart: {},
    pointers: {},
    pinch: false,
    pinchStart: {},
    view: document.getElementById(`canvas-${knife}`),
    vCtx: document.getElementById(`canvas-${knife}`).getContext('2d'),
    full: document.createElement('canvas'),
    fCtx: document.createElement('canvas').getContext('2d'),
    wrapper: document.getElementById(`wrapper-${knife}`),
    overlayEl: document.getElementById(`overlay-${knife}`),
    bbox: document.getElementById(`bbox-${knife}`),
    textInput: document.getElementById(`text-${knife}`),
    fontSel: document.getElementById(`font-${knife}`),
    sameContentChk: showSameContent ? document.getElementById(`same-content-${knife}`) : null,
    cacheCanvas: document.createElement('canvas'),
    cacheCtx: document.createElement('canvas').getContext('2d'),
    textCacheCanvas: document.createElement('canvas'),
    textCacheCtx: document.createElement('canvas').getContext('2d'),
    cacheValid: false,
    textCacheValid: false,
    lastDragTime: 0,
    lastScaleTime: 0
  };
  state[knife].full.width = 0;
  state[knife].full.height = 0;
  state[knife].fCtx = state[knife].full.getContext('2d');
  state[knife].cacheCanvas.width = 0;
  state[knife].cacheCanvas.height = 0;
  state[knife].cacheCtx = state[knife].cacheCanvas.getContext('2d');
  state[knife].textCacheCanvas.width = 0;
  state[knife].textCacheCanvas.height = 0;
  state[knife].textCacheCtx = state[knife].textCacheCanvas.getContext('2d');
}

function draw(knife) {
  const s = state[knife];
  if (!s.img) return;

  const isBigKnife = knives.big.includes(knife);
  const isRightAligned = isBigKnife ? autoAlignBig : autoAlignSmall;

  // Cache base image and overlay if not valid
  if (!s.cacheValid) {
    s.cacheCanvas.width = s.full.width;
    s.cacheCanvas.height = s.full.height;
    s.cacheCtx.clearRect(0, 0, s.full.width, s.full.height);
    s.cacheCtx.drawImage(s.img, 0, 0);
    if (showEditZone && s.overlay) {
      s.cacheCtx.drawImage(s.overlay, 0, 0, s.full.width, s.full.height);
    }
    s.cacheValid = true;
  }

  // Cache text if not valid
  if (!s.textCacheValid || s.textInput.value) {
    s.textCacheCanvas.width = s.full.width;
    s.textCacheCanvas.height = s.full.height;
    s.textCacheCtx.clearRect(0, 0, s.full.width, s.full.height);
    s.textCacheCtx.font = `${s.baseFont * s.textScale}px ${s.fontSel.value}`;
    s.textCacheCtx.fillStyle = '#000';
    s.textCacheCtx.textBaseline = 'top';
    s.textCacheCtx.textAlign = isRightAligned ? 'right' : 'left';
    const x = isRightAligned ? s.pos.x : s.pos.x;
    s.textCacheCtx.fillText(s.textInput.value, x, s.pos.y);
    s.textCacheValid = true;
  }

  // Full-res canvas
  s.fCtx.clearRect(0, 0, s.full.width, s.full.height);
  s.fCtx.drawImage(s.cacheCanvas, 0, 0);
  s.fCtx.drawImage(s.textCacheCanvas, 0, 0);

  // Preview canvas
  const devicePixelRatio = window.devicePixelRatio || 1;
  const scale = s.view.width / s.full.width / devicePixelRatio;
  s.vCtx.setTransform(scale, 0, 0, scale, 0, 0);
  s.vCtx.clearRect(0, 0, s.full.width, s.full.height);
  s.vCtx.drawImage(s.cacheCanvas, 0, 0);
  s.vCtx.drawImage(s.textCacheCanvas, 0, 0);
  s.vCtx.setTransform(1, 0, 0, 1, 0, 0);

  // Bounding box
  const dx = s.view.width / s.full.width / devicePixelRatio;
  const dy = s.view.height / s.full.height / devicePixelRatio;
  if (s.boxVisible && s.textInput.value) {
    s.bbox.style.display = 'block';
    const width = s.baseDims.w * s.textScale * dx;
    s.bbox.style.width = width + 'px';
    s.bbox.style.height = (s.baseDims.h * s.textScale * dy) + 'px';
    s.bbox.style.left = (isRightAligned ? s.pos.x * dx - width : s.pos.x * dx) + 'px';
    s.bbox.style.top = (s.pos.y * dy) + 'px';
  } else {
    s.bbox.style.display = 'none';
  }
}

function invalidateCache(knife) {
  state[knife].cacheValid = false;
}

function invalidateTextCache(knife) {
  state[knife].textCacheValid = false;
}

function syncFontAndText(knife) {
  if (!syncFonts) return;
  const refState = state[knife];
  const fontFamily = refState.fontSel.value;
  const effectiveFontSize = refState.baseFont * refState.textScale;
  const isBigKnife = knives.big.includes(knife);
  Object.keys(state).forEach(k => {
    if (k !== knife && knives.big.includes(k) === isBigKnife) {
      state[k].fontSel.value = fontFamily;
      state[k].baseFont = effectiveFontSize;
      state[k].textScale = 1;
      state[k].baseDims = measureText(state[k].fCtx, state[k].textInput.value || 'Sample', state[k].baseFont, state[k].fontSel.value);
      invalidateTextCache(k);
      draw(k);
    }
  });
  if (isBigKnife) {
    lastBigKnifeFont = fontFamily;
  }
}

function debounceToggle(fn, id, icon) {
  return () => {
    const now = Date.now();
    if (now - lastToggleTime < toggleDebounce) return;
    lastToggleTime = now;
    console.log(`Toggling ${id}`);
    fn();
    const buttons = document.querySelectorAll(`#${id}`);
    buttons.forEach(btn => {
      btn.innerHTML = `<span class="material-symbols-outlined">${icon}</span>`;
      if (id === 'resize-controls') {
        btn.classList.toggle('off', !showResizeControls);
      } else if (id === 'sync-fonts') {
        btn.classList.toggle('off', !syncFonts);
      } else if (id === 'auto-align') {
        const activePage = Object.keys(pages).find(p => pages[p].classList.contains('active'));
        const isBigKnife = activePage === '2';
        btn.classList.toggle('off', isBigKnife ? !autoAlignBig : !autoAlignSmall);
      } else if (id === 'edit-zone') {
        btn.classList.toggle('off', !showEditZone);
      }
    });
  };
}

function toggleEditZone() {
  showEditZone = !showEditZone;
  Object.keys(state).forEach(knife => {
    invalidateCache(knife);
    requestAnimationFrame(() => draw(knife));
  });
}

function toggleResizeControls() {
  showResizeControls = !showResizeControls;
  Object.keys(state).forEach(knife => {
    state[knife].boxVisible = showResizeControls;
    requestAnimationFrame(() => draw(knife));
  });
}

function toggleSyncFonts() {
  syncFonts = !syncFonts;
  if (syncFonts && Object.keys(state).length > 0) {
    const bigKnife = Object.keys(state).find(k => knives.big.includes(k));
    const smallKnife = Object.keys(state).find(k => knives.small.includes(k));
    if (bigKnife) syncFontAndText(bigKnife);
    if (smallKnife) syncFontAndText(smallKnife);
  }
}

function toggleAlignment(knife) {
  const isBigKnife = knives.big.includes(knife);
  if (isBigKnife) {
    autoAlignBig = !autoAlignBig;
    if (autoAlignBig) {
      const refPos = state[knife].pos;
      Object.keys(state).forEach(k => {
        if (knives.big.includes(k)) {
          state[k].pos.x = refPos.x;
          state[k].pos.y = refPos.y;
          invalidateTextCache(k);
          draw(k);
        }
      });
    }
  } else {
    autoAlignSmall = !autoAlignSmall;
    if (autoAlignSmall) {
      const refPos = state[knife].pos;
      Object.keys(state).forEach(k => {
        if (knives.small.includes(k)) {
          state[k].pos.x = refPos.x;
          state[k].pos.y = refPos.y;
          invalidateTextCache(k);
          draw(k);
        }
      });
    }
  }
}

async function generatePreviews() {
  previewContent.innerHTML = '';
  for (const knife of Object.keys(state)) {
    const s = state[knife];
    draw(knife);
    const previewUrl = s.full.toDataURL('image/png');
    const div = document.createElement('div');
    div.className = 'preview-item';
    div.innerHTML = `
      <img src="${previewUrl}" alt="${knife} preview" data-knife="${knife}">
      <span data-i18n="${knife}Knife">${translations[currentLang][`${knife}Knife`]}</span>
    `;
    previewContent.appendChild(div);
  }
  previewContent.querySelectorAll('img').forEach(img => {
    img.addEventListener('click', () => {
      modalImage.src = img.src;
      modal.style.display = 'flex';
    });
  });
}

modal.addEventListener('click', () => {
  modal.style.display = 'none';
  modalImage.src = '';
});

document.fonts.ready.then(() => {
  Object.keys(state).forEach(knife => draw(knife));
});

next1Btn.addEventListener('click', async () => {
  if (isNavigating) return;
  const selected = Array.from(productPicker.querySelectorAll('input:checked'));
  if (selected.length === 0) return;
  bigKnifeContent.innerHTML = '';
  smallKnifeContent.innerHTML = '';
  Object.keys(state).forEach(knife => delete state[knife]);
  firstSelectedKnife = selected[0].dataset.name;

  const hasBig = hasBigKnives(selected);
  const hasSmall = hasSmallKnives(selected);

  if (hasBig) {
    switchPage(1, 2);
    for (const input of selected) {
      const knife = input.dataset.name;
      if (knives.big.includes(knife)) {
        await initializeKnife(knife);
      }
    }
  } else if (hasSmall) {
    switchPage(1, 3);
    for (const input of selected) {
      const knife = input.dataset.name;
      if (knives.small.includes(knife)) {
        await initializeKnife(knife);
      }
    }
  }
});

back2Btn.addEventListener('click', () => {
  switchPage(2, 1);
});

next2Btn.addEventListener('click', async () => {
  if (isNavigating) return;
  const selected = Array.from(productPicker.querySelectorAll('input:checked'));
  const hasSmall = hasSmallKnives(selected);
  if (hasSmall) {
    switchPage(2, 3);
    for (const input of selected) {
      const knife = input.dataset.name;
      if (knives.small.includes(knife) && !state[knife]) {
        await initializeKnife(knife);
      }
    }
  } else {
    switchPage(2, 4);
    await generatePreviews();
  }
});

back3Btn.addEventListener('click', () => {
  const selected = Array.from(productPicker.querySelectorAll('input:checked'));
  const hasBig = hasBigKnives(selected);
  if (hasBig) {
    switchPage(3, 2);
  } else {
    switchPage(3, 1);
  }
});

next3Btn.addEventListener('click', async () => {
  if (isNavigating) return;
  switchPage(3, 4);
  await generatePreviews();
});

back4Btn.addEventListener('click', () => {
  const selected = Array.from(productPicker.querySelectorAll('input:checked'));
  const hasSmall = hasSmallKnives(selected);
  const hasBig = hasBigKnives(selected);
  if (hasSmall) {
    switchPage(4, 3);
  } else if (hasBig) {
    switchPage(4, 2);
  } else {
    switchPage(4, 1);
  }
});

document.addEventListener('click', e => {
  if (e.target.id === 'edit-zone' || e.target.closest('#edit-zone')) {
    debounceToggle(toggleEditZone, 'edit-zone', 'vignette')();
  } else if (e.target.id === 'resize-controls' || e.target.closest('#resize-controls')) {
    debounceToggle(toggleResizeControls, 'resize-controls', 'format_shapes')();
  } else if (e.target.id === 'sync-fonts' || e.target.closest('#sync-fonts')) {
    debounceToggle(toggleSyncFonts, 'sync-fonts', 'format_size')();
  } else if (e.target.id === 'auto-align' || e.target.closest('#auto-align')) {
    const activePage = Object.keys(pages).find(p => pages[p].classList.contains('active'));
    const knife = activePage === '2' ? Object.keys(state).find(k => knives.big.includes(k)) :
                  activePage === '3' ? Object.keys(state).find(k => knives.small.includes(k)) : null;
    if (knife) {
      debounceToggle(() => toggleAlignment(knife), 'auto-align', 'recenter')();
    }
  }
});

async function initializeKnife(knife) {
  createCanvasSection(knife);
  const s = state[knife];
  s.overlayEl.style.visibility = 'visible';
  s.img = await loadImage(
    productPicker.querySelector(`input[data-name="${knife}"]`).value
  );
  try {
    s.overlay = await loadImage(`${knife}-overlay.png`);
  } catch (e) {
    console.warn(`Overlay image for ${knife} not found`);
    s.overlay = null;
  }
  s.full.width = s.img.naturalWidth;
  s.full.height = s.img.naturalHeight;
  s.cacheCanvas.width = s.full.width;
  s.cacheCanvas.height = s.full.height;
  s.textCacheCanvas.width = s.full.width;
  s.textCacheCanvas.height = s.full.height;
  fitInBox(s.view, s.img, s.wrapper);
  const isBigKnife = knives.big.includes(knife);
  s.fontSel.value = isBigKnife ? lastBigKnifeFont : lastBigKnifeFont;
  s.baseDims = measureText(s.fCtx, s.textInput.value || 'Sample', s.baseFont, s.fontSel.value);
  s.textScale = 1;

  if (sameContent && sharedText) {
    s.textInput.value = sharedText;
    s.baseDims = measureText(s.fCtx, s.textInput.value || 'Sample', s.baseFont, s.fontSel.value);
  }

  s.pos.x = s.full.width - 20; // Start right-aligned
  s.pos.y = 20;

  document.fonts.load(`${s.baseFont}px ${s.fontSel.value}`).then(() => {
    s.baseDims = measureText(s.fCtx, s.textInput.value || 'Sample', s.baseFont, s.fontSel.value);
    draw(knife);
  });

  draw(knife);

  s.textInput.addEventListener('input', () => {
    if (sameContent) {
      sharedText = s.textInput.value;
      Object.keys(state).forEach(k => {
        state[k].textInput.value = sharedText;
        state[k].baseDims = measureText(state[k].fCtx, state[k].textInput.value || 'Sample', state[k].baseFont, state[k].fontSel.value);
        invalidateTextCache(k);
        draw(k);
      });
    } else {
      s.baseDims = measureText(s.fCtx, s.textInput.value || 'Sample', s.baseFont, s.fontSel.value);
      invalidateTextCache(knife);
      draw(knife);
    }
  });

  s.fontSel.addEventListener('input', () => {
    document.fonts.load(`${s.baseFont}px ${s.fontSel.value}`).then(() => {
      s.baseDims = measureText(s.fCtx, s.textInput.value || 'Sample', s.baseFont, s.fontSel.value);
      invalidateTextCache(knife);
      draw(knife);
      syncFontAndText(knife);
    });
    setTimeout(() => draw(knife), 500);
  });

  if (s.sameContentChk) {
    s.sameContentChk.addEventListener('change', () => {
      sameContent = s.sameContentChk.checked;
      if (sameContent) {
        sharedText = s.textInput.value;
        Object.keys(state).forEach(k => {
          state[k].textInput.value = sharedText;
          state[k].baseDims = measureText(state[k].fCtx, state[k].textInput.value || 'Sample', state[k].baseFont, state[k].fontSel.value);
          invalidateTextCache(k);
          draw(k);
        });
      } else {
        sharedText = '';
      }
    });
  }

  s.view.addEventListener('pointerdown', e => {
    const isBigKnife = knives.big.includes(knife);
    const isRightAligned = isBigKnife ? autoAlignBig : autoAlignSmall;
    const f = toFullCoords(s.view, s, e.clientX, e.clientY);
    if (!hitTest(f.x, f.y, s.pos, s.baseDims, s.textScale, isRightAligned) || s.resizing) return;
    console.log(`Dragging started for ${knife}`);
    s.dragging = true;
    s.dragStart = { id: e.pointerId, dx: f.x - s.pos.x, dy: f.y - s.pos.y };
    e.preventDefault();
  });

  window.addEventListener('pointermove', e => {
    if (!s.dragging || e.pointerId !== s.dragStart.id) return;
    const now = Date.now();
    if (now - s.lastDragTime < dragThrottle) return;
    s.lastDragTime = now;
    console.log(`Dragging ${knife}`);
    const f = toFullCoords(s.view, s, e.clientX, e.clientY);
    s.pos.x = f.x - s.dragStart.dx;
    s.pos.y = f.y - s.dragStart.dy;
    const isBigKnife = knives.big.includes(knife);
    const autoAlign = isBigKnife ? autoAlignBig : autoAlignSmall;
    if (autoAlign) {
      Object.keys(state).forEach(k => {
        if (k !== knife && knives.big.includes(k) === isBigKnife) {
          state[k].pos.x = s.pos.x;
          state[k].pos.y = s.pos.y;
          invalidateTextCache(k);
          draw(k);
        }
      });
    }
    invalidateTextCache(knife);
    requestAnimationFrame(() => draw(knife));
    lastAdjusted[knives.big.includes(knife) ? 'big' : 'small'] = knife;
  });

  ['pointerup', 'pointercancel'].forEach(evt =>
    window.addEventListener(evt, e => {
      if (e.pointerId === s.dragStart.id) {
        console.log(`Dragging stopped for ${knife}`);
        s.dragging = false;
      }
    })
  );

  s.bbox.querySelectorAll('.handle').forEach(h => {
    h.addEventListener('pointerdown', e => {
      e.stopPropagation();
      console.log(`Resizing started for ${knife}`);
      s.resizing = true;
      const handle = h.dataset.handle;
      const box = s.bbox.getBoundingClientRect();
      const p0 = toFullCoords(s.view, s, e.clientX, e.clientY);
      s.resizeStart = {
        id: e.pointerId,
        handle,
        x0: s.pos.x,
        y0: s.pos.y,
        scale: s.textScale,
        px: p0.x,
        py: p0.y,
        w0: s.baseDims.w,
        h0: s.baseDims.h
      };
    });
  });

  window.addEventListener('pointermove', e => {
    if (!s.resizing || e.pointerId !== s.resizeStart.id) return;
    const now = Date.now();
    if (now - s.lastScaleTime < scaleDebounce) return;
    s.lastScaleTime = now;
    console.log(`Resizing ${knife}`);
    const p = toFullCoords(s.view, s, e.clientX, e.clientY);
    const { handle, x0, y0, scale, px, py, w0, h0 } = s.resizeStart;
    const isBigKnife = knives.big.includes(knife);
    const isRightAligned = isBigKnife ? autoAlignBig : autoAlignSmall;
    let newScale, newX, newY;

    if (handle === 'se') {
      const dx = isRightAligned ? px - p.x : p.x - px;
      const dy = p.y - py;
      newScale = scale * Math.max(dx / (w0 * scale), dy / (h0 * scale));
      newX = isRightAligned ? x0 + w0 * scale - w0 * newScale : x0;
      newY = y0;
    } else if (handle === 'nw') {
      const dx = isRightAligned ? p.x - px : px - p.x;
      const dy = py - p.y;
      newScale = scale * Math.max(dx / (w0 * scale), dy / (h0 * scale));
      newX = isRightAligned ? x0 : x0 + w0 * scale - w0 * newScale;
      newY = y0 + h0 * scale - h0 * newScale;
    } else if (handle === 'ne') {
      const dx = isRightAligned ? px - p.x : p.x - px;
      const dy = py - p.y;
      newScale = scale * Math.max(dx / (w0 * scale), dy / (h0 * scale));
      newX = isRightAligned ? x0 + w0 * scale - w0 * newScale : x0;
      newY = y0 + h0 * scale - h0 * newScale;
    } else if (handle === 'sw') {
      const dx = isRightAligned ? p.x - px : px - p.x;
      const dy = p.y - py;
      newScale = scale * Math.max(dx / (w0 * scale), dy / (h0 * scale));
      newX = isRightAligned ? x0 : x0 + w0 * scale - w0 * newScale;
      newY = y0;
    }

    if (newScale > 0.1 && newScale < 10) {
      s.textScale = newScale;
      s.pos.x = newX;
      s.pos.y = newY;
      const isBigKnife = knives.big.includes(knife);
      const autoAlign = isBigKnife ? autoAlignBig : autoAlignSmall;
      const affectedKnives = [knife];
      if (autoAlign || syncFonts) {
        Object.keys(state).forEach(k => {
          if (k !== knife && knives.big.includes(k) === isBigKnife) {
            if (autoAlign) {
              state[k].pos.x = newX;
              state[k].pos.y = newY;
            }
            if (syncFonts) {
              state[k].baseFont = s.baseFont * newScale;
              state[k].textScale = 1;
              state[k].baseDims = measureText(state[k].fCtx, state[k].textInput.value || 'Sample', state[k].baseFont, state[k].fontSel.value);
            }
            affectedKnives.push(k);
          }
        });
      }
      invalidateTextCache(knife);
      requestAnimationFrame(() => {
        affectedKnives.forEach(k => draw(k));
      });
      lastAdjusted[knives.big.includes(knife) ? 'big' : 'small'] = knife;
      if (syncFonts) syncFontAndText(knife);
    }
  });

  ['pointerup', 'pointercancel'].forEach(evt =>
    window.addEventListener(evt, e => {
      if (e.pointerId === s.resizeStart.id) {
        console.log(`Resizing stopped for ${knife}`);
        s.resizing = false;
      }
    })
  );

  s.view.addEventListener('pointerdown', e => {
    s.pointers[e.pointerId] = { x: e.clientX, y: e.clientY };
    if (Object.keys(s.pointers).length === 2 && !s.dragging && !s.resizing) {
      console.log(`Pinch started for ${knife}`);
      s.pinch = true;
      const [pA, pB] = Object.values(s.pointers);
      const fA = toFullCoords(s.view, s, pA.x, pA.y);
      const fB = toFullCoords(s.view, s, pB.x, pB.y);
      s.pinchStart = {
        scale: s.textScale,
        x0: s.pos.x,
        y0: s.pos.y,
        px0: (fA.x + fB.x) / 2,
        py0: (fA.y + fB.y) / 2,
        d0: Math.hypot(fA.x - fB.x, fA.y - fB.y)
      };
    }
  });

  s.view.addEventListener('pointermove', e => {
    if (!s.pinch || !(e.pointerId in s.pointers)) return;
    const now = Date.now();
    if (now - s.lastScaleTime < scaleDebounce) return;
    s.lastScaleTime = now;
    console.log(`Pinching ${knife}`);
    s.pointers[e.pointerId] = { x: e.clientX, y: e.clientY };
    const [a, b] = Object.values(s.pointers);
    const fA = toFullCoords(s.view, s, a.x, a.y);
    const fB = toFullCoords(s.view, s, b.x, b.y);
    const d1 = Math.hypot(fA.x - fB.x, fA.y - fB.y);
    const newScale = s.pinchStart.scale * (d1 / s.pinchStart.d0);
    const px1 = (fA.x + fB.x) / 2;
    const py1 = (fA.y + fB.y) / 2;
    const dx = px1 - s.pinchStart.px0;
    const dy = py1 - s.pinchStart.py0;
    s.textScale = newScale;
    s.pos.x = s.pinchStart.x0 + dx;
    s.pos.y = s.pinchStart.y0 + dy;
    const isBigKnife = knives.big.includes(knife);
    const autoAlign = isBigKnife ? autoAlignBig : autoAlignSmall;
    const affectedKnives = [knife];
    if (autoAlign || syncFonts) {
      Object.keys(state).forEach(k => {
        if (k !== knife && knives.big.includes(k) === isBigKnife) {
          if (autoAlign) {
            state[k].pos.x = s.pos.x;
            state[k].pos.y = s.pos.y;
          }
          if (syncFonts) {
            state[k].baseFont = s.baseFont * newScale;
            state[k].textScale = 1;
            state[k].baseDims = measureText(state[k].fCtx, state[k].textInput.value || 'Sample', state[k].baseFont, state[k].fontSel.value);
          }
          affectedKnives.push(k);
        }
      });
    }
    invalidateTextCache(knife);
    requestAnimationFrame(() => {
      affectedKnives.forEach(k => draw(k));
    });
    lastAdjusted[knives.big.includes(knife) ? 'big' : 'small'] = knife;
    if (syncFonts) syncFontAndText(knife);
  });

  ['pointerup', 'pointercancel'].forEach(evt =>
    s.view.addEventListener(evt, e => {
      delete s.pointers[e.pointerId];
      if (Object.keys(s.pointers).length < 2) {
        console.log(`Pinch stopped for ${knife}`);
        s.pinch = false;
      }
    })
  );

  s.overlayEl.style.visibility = 'hidden';
}

downloadBtn.addEventListener('click', async () => {
  const zip = new JSZip();
  for (const knife of Object.keys(state)) {
    const s = state[knife];
    draw(knife);

    const previewBlob = await new Promise(r => s.full.toBlob(r));
    zip.file(`${knife}-preview.png`, previewBlob);

    const t = document.createElement('canvas');
    t.width = s.full.width;
    t.height = s.full.height;
    const tCtx = t.getContext('2d');
    tCtx.font = `${s.baseFont * s.textScale}px ${s.fontSel.value}`;
    tCtx.fillStyle = '#000';
    tCtx.textBaseline = 'top';
    tCtx.textAlign = knives.big.includes(knife) && autoAlignBig || knives.small.includes(knife) && autoAlignSmall ? 'right' : 'left';
    const x = tCtx.textAlign === 'right' ? s.pos.x : s.pos.x;
    tCtx.fillText(s.textInput.value, x, s.pos.y);
    const textBlob = await new Promise(r => t.toBlob(r));
    zip.file(`${knife}-text-only.png`, textBlob);
  }

  const zipBlob = await zip.generateAsync({ type: 'blob' });
  const url = URL.createObjectURL(zipBlob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'knife-engravings.zip';
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    URL.revokeObjectURL(url);
    a.remove();
  }, 100);
});

updateLanguage(currentLang);
  </script>
</body>
</html>
