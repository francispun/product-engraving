<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
  <title>Knife Engraving Customiser</title>
  <link rel="icon" type="image/x-icon" href="./favicon.ico">

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto&family=Lobster&family=Chocolate+Classical+Sans&family=LXGW+WenKai+Mono+TC&family=Noto+Sans+HK&family=Noto+Serif+TC&display=swap" rel="stylesheet">

  <!-- Material Symbols -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

  <!-- JSZip for ZIP download -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <style>
    :root {
      --accent: #d00024;
      --gray: #888;
      --bg: #fafafa;
      --border: #ddd;
      --pad: 2rem;
      --radius: .5rem;
      --mpad: 1rem;
    }
    * { box-sizing: border-box; margin: 0; }
    body {
      font-family: Roboto, 'Noto Sans HK', Arial, sans-serif;
      background: #474a51;
      color: #ffffff;
      padding-bottom: 60px;
    }
    h1, h2, h3 { text-align: center; margin: 1rem 0; }
    h3 { margin-bottom: 1rem; }
    .container {
      max-width: 1200px; margin: auto; padding: var(--pad);
      display: flex; flex-direction: column; gap: var(--pad);
    }
    .page {
      display: none;
    }
    .page.active {
      display: block;
    }
    .section {
      background: #fff; border: 1px solid var(--border);
      border-radius: var(--radius); padding: var(--pad);
    }
    #product-picker {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      padding-bottom: 4rem;
    }
    .product-option {
      position: relative;
      text-align: center;
      height: 210px;
      display: grid;
      align-items: center;
      justify-content: center;
    }
    .product-option input {
      position: absolute; inset: 0; opacity: 0; cursor: pointer;
    }
    .product-option img {
      max-width: 100%;
      max-height: 210px;
      object-fit: contain;
      border: 2px solid transparent;
      border-radius: var(--radius);
      display: block;
    }
    .product-option input:checked+img {
      border-color: var(--accent);
      border-width: medium;
    }
    .product-option span {
      display: block;
      font-size: .9rem;
      margin-top: .25rem;
    }
    .controls {
      display: flex; flex-wrap: wrap; gap: 1rem; align-items: center;
    }
    .controls label { font-size: .9rem; margin-right: .25rem; }
    .controls input[type="text"] {
      width: 250px;
      height: 33px;
      padding: .5rem;
      border: 1px solid var(--border);
      border-radius: var(--radius);
    }
    .controls select {
      height: 33px;
      border-radius: 7px;
    }
    .canvas-wrapper {
      position: relative;
      width: 100%; max-width: 1168px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: #eaeaea;
      overflow: hidden;
      touch-action: none;
      margin: auto;
    }
    .canvas-wrapper canvas {
      border-radius: var(--radius);
    }
    canvas {
      display: block;
      touch-action: none;
    }
    .loading-overlay {
      position: absolute; inset: 0;
      background: rgba(255,255,255,0.85);
      display: flex; align-items: center; justify-content: center;
      font-size: 1.5rem; color: #555;
      visibility: hidden; z-index: 10;
    }
    .bbox {
      position: absolute; border: 1px dashed #000;
      pointer-events: none; display: none;
      z-index: 30;
    }
    .handle {
      position: absolute; width: 10px; height: 10px;
      background: #fff; border: 1px solid #000;
      pointer-events: auto;
      z-index: 31;
    }
    .handle[data-handle="nw"] { top: -5px; left: -5px; cursor: nwse-resize; }
    .handle[data-handle="ne"] { top: -5px; right: -5px; cursor: nesw-resize; }
    .handle[data-handle="sw"] { bottom: -5px; left: -5px; cursor: nesw-resize; }
    .handle[data-handle="se"] { bottom: -5px; right: -5px; cursor: nwse-resize; }
    button {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: .6rem;
      border-radius: var(--radius);
      cursor: pointer;
      font-weight: 600;
      font-size: 1rem;
      margin: 0 .25rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    button[disabled] {
      opacity: .4; cursor: not-allowed;
    }
    button.off {
      background: var(--gray);
    }
    .material-symbols-outlined {
      font-size: 24px;
      vertical-align: middle;
    }
    #edit-zone .material-symbols-outlined {
      font-variation-settings: 'FILL' 1;
    }
    .same-content {
      display: block; margin-top: .5rem;
    }
    .knife-section {
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--pad);
      margin-bottom: 1rem;
    }
    .navigation {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      background: rgb(51, 57, 68);
      padding: 1rem;
      display: flex;
      justify-content: center;
      gap: 0.6rem;
      z-index: 100;
      flex-wrap: nowrap;
      overflow-x: auto;
      white-space: nowrap;
      margin: 20px 0;
      width: auto;
      max-width: 510px;
      border-radius: 18px;
      box-shadow: 0px 0px 5px #2f3138;
    }
    .preview-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .preview-item {
      text-align: center;
    }
    .preview-item img {
      width: 100%;
      max-width: 100%;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      cursor: pointer;
    }
    .preview-item span {
      display: block;
      font-size: .9rem;
      margin-top: .5rem;
    }
    .preview-description {
      text-align: center;
      font-size: .9rem;
      color: #666;
      margin-bottom: 1rem;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: .5rem;
    }
    .modal img {
      max-width: 90%;
      max-height: 85%;
      border-radius: var(--radius);
    }
    .modal span {
      color: #fff;
      font-size: 1rem;
    }
    #lang-toggle {
      display: none;
      margin: 0 auto 1rem;
      padding: .5rem 1rem;
      text-align: center;
    }
    #page-1.active #lang-toggle {
      display: block;
    }
    .knife-section p {
      margin: 11px 0px;
      color: #a5a5a5 !important;
    }
    div#page-1 {
      color: #4c4c4c;
    }
    .button-guide {
        background: #fff;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        padding: var(--pad);
         margin-bottom: 1rem;
      }
      .button-guide h3 {
        margin-bottom: 1rem;
        color: #000;
      }
      .button-list {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .button-item {
        display: flex;
        align-items: center;
        gap: 1rem;
      }
      .guide-button {
        background: var(--accent);
        color: #fff;
        border: none;
        padding: .6rem;
        border-radius: var(--radius);
        cursor: default;
        font-weight: 600;
        font-size: 1rem;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 40px;
      }
      .button-desc h4 {
        font-size: 1rem;
        margin-bottom: .25rem;
        color: #333;
      }
      .button-desc p {
        font-size: .9rem;
        color: #666;
        margin-bottom: .25rem;
      }
      .alert-content {
        background: #fff;
        padding: 1.5rem;
        border-radius: var(--radius);
        text-align: center;
        max-width: 90%;
        width: 400px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }
      .alert-content p {
        color: #333;
        font-size: 1rem;
        margin-bottom: 1rem;
      }
      #alert-close {
        background: var(--accent);
        color: #fff;
        padding: .5rem 1rem;
        border: none;
        border-radius: var(--radius);
        cursor: pointer;
        display: inline-block;
      }
    .disclaimer {
      background: #fff;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--pad);
      margin-bottom: 1rem;
    }
    .disclaimer h3 {
      margin-bottom: 1rem;
      color: #000;
    }
    .disclaimer p {
      font-size: .9rem;
      color: #666;
      line-height: 1.5;
    }
    @media (max-width: 600px) {
      .section { padding: var(--mpad); };
      .controls {
        flex-direction: column;
        align-items: flex-start;
        display: block;
      }
      .controls div {
        margin: 10px 0px;
      }
      .controls input[type="text"] {
        width: 100%;
        max-width: 250px;
      }
      button {
        padding: .5rem;
        font-size: .9rem;
      }
      .material-symbols-outlined {
        font-size: 20px;
      }
      #lang-toggle {
        margin: 0 auto .5rem;
        padding: .4rem .8rem;
        font-size: .9rem;
      }
      .modal span {
        font-size: .9rem;
      }
      .button-guide {
        padding: .5rem;
      }
      .button-item {
        flex-direction: column;
        align-items: center;
        text-align: center;
      }
      .guide-button {
        padding: .5rem;
        min-width: 36px;
      }
      .button-desc h4 {
        font-size: .9rem;
      }
      .button-desc p {
        font-size: .8rem;
      }
      .disclaimer {
          padding: .5rem;
        }
        .disclaimer h3 {
          font-size: 1rem;
        }
        .disclaimer p {
          font-size: .8rem;
        }
      }
      }
    }
  </style>
</head>
<body>
  <h1 id="title">Knife Engraving Customiser</h1>
  <h3 id="subtitle">by <img src="kool-logo.png" alt="logo" style="width:50px;vertical-align:bottom;"></h3>
  <div class="container">
    <!-- Page 1: Knife Selection -->
    <div id="page-1" class="page section active">
      <button id="lang-toggle">中文</button>
      <h2 data-i18n="chooseKnives">Choose your knives</h2>
      <div id="product-picker">
        <label class="product-option">
          <input type="checkbox" name="product" value="chef.jpg" data-thumb="chef-thumb.jpg" data-name="chef">
          <img src="chef-thumb.jpg" alt="Chef knife">
          <span data-i18n="chefKnife">Chef Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="santoku.jpg" data-thumb="santoku-thumb.jpg" data-name="santoku">
          <img src="santoku-thumb.jpg" alt="Santoku knife">
          <span data-i18n="santokuKnife">Santoku Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="bread.jpg" data-thumb="bread-thumb.jpg" data-name="bread">
          <img src="bread-thumb.jpg" alt="Bread knife">
          <span data-i18n="breadKnife">Bread Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="chopper.jpg" data-thumb="chopper-thumb.jpg" data-name="chopper">
          <img src="chopper-thumb.jpg" alt="Chopper knife">
          <span data-i18n="chopperKnife">Chopper Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="utility.jpg" data-thumb="utility-thumb.jpg" data-name="utility">
          <img src="utility-thumb.jpg" alt="Utility knife">
          <span data-i18n="utilityKnife">Utility Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="paring.jpg" data-thumb="paring-thumb.jpg" data-name="paring">
          <img src="paring-thumb.jpg" alt="Paring knife">
          <span data-i18n="paringKnife">Paring Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="tongs.jpg" data-thumb="tongs-thumb.jpg" data-name="tongs">
          <img src="tongs-thumb.jpg" alt="Tongs">
          <span data-i18n="tongs">Tongs</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="scissors.jpg" data-thumb="scissors-thumb.jpg" data-name="scissors">
          <img src="scissors-thumb.jpg" alt="Scissors">
          <span data-i18n="scissors">Scissors</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="chopping-board.jpg" data-thumb="chopping-board-thumb.jpg" data-name="choppingBoard">
          <img src="chopping-board-thumb.jpg" alt="Chopping board">
          <span data-i18n="choppingBoard">Chopping Board</span>
        </label>
      </div>
      <div class="navigation">
        <button id="next-1"><span class="material-symbols-outlined">arrow_forward_ios</span></button>
      </div>
    </div>

    <!-- Page 2: Big Knives Customization -->
    <div id="page-2" class="page">
      <div id="big-knife-content"></div>
      <div class="navigation">
        <button id="back-2"><span class="material-symbols-outlined">arrow_back_ios_new</span></button>
        <button id="edit-zone"><span class="material-symbols-outlined">vignette</span></button>
        <button id="resize-controls"><span class="material-symbols-outlined">format_shapes</span></button>
        <button id="sync-fonts"><span class="material-symbols-outlined">format_size</span></button>
        <button id="auto-align"><span class="material-symbols-outlined">recenter</span></button>
        <button id="next-2"><span class="material-symbols-outlined">arrow_forward_ios</span></button>
      </div>
    </div>

    <!-- Page 3: Small Knives Customization -->
    <div id="page-3" class="page">
      <div id="small-knife-content"></div>
      <div class="navigation">
        <button id="back-3"><span class="material-symbols-outlined">arrow_back_ios_new</span></button>
        <button id="edit-zone"><span class="material-symbols-outlined">vignette</span></button>
        <button id="resize-controls"><span class="material-symbols-outlined">format_shapes</span></button>
        <button id="sync-fonts"><span class="material-symbols-outlined">format_size</span></button>
        <button id="auto-align"><span class="material-symbols-outlined">recenter</span></button>
        <button id="next-3"><span class="material-symbols-outlined">arrow_forward_ios</span></button>
      </div>
    </div>

    <!-- Page 4: Preview and Download -->
    <div id="page-4" class="page section">
      <h2 data-i18n="previewAllKnives">Preview All Knives</h2>
      <div class="preview-description" data-i18n="previewDescription">Click any image to enlarge</div>
      <div id="preview-content" class="preview-list"></div>
      <div class="navigation">
        <button id="back-4"><span class="material-symbols-outlined">arrow_back_ios_new</span></button>
        <button id="download-all"><span class="material-symbols-outlined">download_2</span></button>
      </div>
    </div>
    
    <!-- Page 5: Non-Knife Items Customization -->
    <div id="page-5" class="page">
      <div id="other-content"></div>
      <div class="navigation">
        <button id="back-5"><span class="material-symbols-outlined">arrow_back_ios_new</span></button>
        <button id="edit-zone"><span class="material-symbols-outlined">vignette</span></button>
        <button id="resize-controls"><span class="material-symbols-outlined">format_shapes</span></button>
        <button id="sync-fonts"><span class="material-symbols-outlined">format_size</span></button>
        <button id="auto-align"><span class="material-symbols-outlined">recenter</span></button>
        <button id="next-5"><span class="material-symbols-outlined">arrow_forward_ios</span></button>
      </div>
    </div>

    <!-- Modal for Enlarged Image -->
    <div id="modal" class="modal">
      <img id="modal-image" src="" alt="Enlarged preview">
      <span data-i18n="modalClose">Click anywhere to close</span>
    </div>

    <div class="button-guide">
      <h3 data-i18n="buttonGuideTitle">How to Use the Controls</h3>
      <div class="button-list">
        <div class="button-item">
          <button class="guide-button"><span class="material-symbols-outlined">arrow_back_ios_new</span></button>
          <div class="button-desc">
            <h4 data-i18n="backCustomize"></h4>
            <p data-i18n="backCustomizeOn"></p>
            <p data-i18n="backCustomizeOff"></p>
          </div>
        </div>
        <div class="button-item">
          <button class="guide-button"><span class="material-symbols-outlined" style="font-variation-settings: 'FILL' 1">vignette</span></button>
          <div class="button-desc">
            <h4 data-i18n="editZoneGuide"></h4>
            <p data-i18n="editZoneOn"></p>
            <p data-i18n="editZoneOff"></p>
          </div>
        </div>
        <div class="button-item">
          <button class="guide-button"><span class="material-symbols-outlined">format_shapes</span></button>
          <div class="button-desc">
            <h4 data-i18n="resizeControlsGuide"></h4>
            <p data-i18n="resizeControlsOn"></p>
            <p data-i18n="resizeControlsOff"></p>
          </div>
        </div>
        <div class="button-item">
          <button class="guide-button"><span class="material-symbols-outlined">format_size</span></button>
          <div class="button-desc">
            <h4 data-i18n="syncFontsGuide"></h4>
            <p data-i18n="syncFontsOn"></p>
            <p data-i18n="syncFontsOff"></p>
          </div>
        </div>
        <div class="button-item">
          <button class="guide-button"><span class="material-symbols-outlined">recenter</span></button>
          <div class="button-desc">
            <h4 data-i18n="autoAlignGuide"></h4>
            <p data-i18n="autoAlignOn"></p>
            <p data-i18n="autoAlignOff"></p>
          </div>
        </div>
        <div class="button-item">
          <button class="guide-button" data-i18n="nextGuide"><span class="material-symbols-outlined">arrow_forward_ios</span></button>
          <div class="button-desc">
            <h4 data-i18n="backPreview"></h4>
            <p data-i18n="backPreviewOn"></p>
            <p data-i18n="backPreviewOff"></p>
          </div>
        </div>
        <div class="button-item">
          <button class="guide-button"><span class="material-symbols-outlined">download_2</span></button>
          <div class="button-desc">
            <h4 data-i18n="downloadGuide"></h4>
            <p data-i18n="downloadOn"></p>
            <p data-i18n="downloadOff"></p>
          </div>
        </div>
      </div>
    </div>
    <!-- Disclaimer -->
    <div class="disclaimer">
      <h3 data-i18n="disclaimerTitle">Disclaimer</h3>
      <p data-i18n="disclaimerText">
        The Knife Engraving Customizer allows you to preview and design personalized engravings on selected products. Please note the following:<br>
        • <strong>Preview Accuracy</strong>: The previews generated are for visualization purposes only and may differ slightly from the final engraved product due to variations in materials, engraving techniques, or device display settings.<br>
        • <strong>Content Responsibility</strong>: You are responsible for ensuring that the text entered is appropriate, non-offensive, and complies with applicable laws. We reserve the right to reject any engraving requests that contain inappropriate or prohibited content.<br>
        • <strong>Font and Weight Limitations</strong>: Some fonts (e.g., Lobster, Chocolate Classical Sans, LXGW WenKai Mono TC) do not support bold weight (700) and will default to their standard weight (400). Final engraving appearance may vary based on font selection.<br>
        • <strong>Production Limitations</strong>: Engraving placement, size, and depth are subject to the physical constraints of the selected product and our engraving equipment. We will make reasonable efforts to match your design, but minor adjustments may be necessary.<br>
        • <strong>No Refunds for Customization</strong>: Due to the personalized nature of engraved products, orders are final and non-refundable unless the product is defective or the engraving significantly deviates from the approved design.<br>
        • <strong>Technical Issues</strong>: While we strive to ensure the tool functions correctly, we are not liable for errors caused by technical issues, such as browser compatibility or incorrect preview rendering.<br>
        By using this tool, you acknowledge and agree to these terms. For questions, contact our customer support.
      </p>
    </div>
    <!-- Custom Alert Modal -->
    <div id="alert-modal" class="modal">
      <div class="alert-content">
        <p id="alert-message"></p>
        <button id="alert-close" data-i18n="close">Close</button>
      </div>
    </div>
  </div>

  <script>
  /* TRANSLATIONS */
  const translations = {
    en: {
      title: "Knife Engraving Customiser",
      subtitle: "by",
      subtitleAfter: "",
      next: "Next",
      back: "Back",
      preview: "Preview",
      previewAllKnives: "Preview All Items",
      previewDescription: "Click any image to enlarge",
      download: "Download",
      chefKnife: "Chef Knife",
      santokuKnife: "Santoku Knife",
      breadKnife: "Bread Knife",
      chopperKnife: "Chopper Knife",
      utilityKnife: "Utility Knife",
      paringKnife: "Paring Knife",
      textLabel: "Text:",
      textPlaceholder: "Enter engraving",
      fontLabel: "Font:",
      sameContentLabel: "Use same text for all",
      instructions: "• Drag text to move.<br>• Drag a corner to scale (desktop).<br>• Pinch to zoom and move text (mobile).",
      editZone: "Edit Zone",
      resizeControls: "Resize Controls",
      syncFonts: "Sync Fonts",
      autoAlignment: "Auto Align",
      loading: "Loading…",
      knife: "Knife",
      english: "English",
      chinese: "Chinese",
      modalClose: "Click anywhere to close",
      buttonGuideTitle: "How to Use the Controls",
      backCustomize: "Back",
      backCustomizeOn: "Returns to the previous page (e.g., item selection).",
      //backCustomizeOff: "N/A (non-toggleable button).",
      editZoneGuide: "Show Edit Area",
      editZoneOn: "ON: Displays the engraving area overlay to guide text placement.",
      editZoneOff: "OFF: Hides the engraving area overlay for a clearer view of the item.",
      resizeControlsGuide: "Show Resize Handles",
      resizeControlsOn: "ON: Shows corner handles to resize and reposition text by dragging.",
      resizeControlsOff: "OFF: Hides resize handles for a cleaner view while keeping text editable.",
      syncFontsGuide: "Sync Text Style",
      syncFontsOn: "ON: Applies the same font and size to all items on the same page.",
      syncFontsOff: "OFF: Allows different fonts and sizes for each item independently.",
      autoAlignGuide: "Auto Align Text",
      autoAlignOn: "Keeps text position aligned across all items on the same page for consistency.",
      autoAlignOff: "Allows independent text positioning for each item.",
      backPreview: "Next",
      backPreviewOn: "Advances to the next page (e.g., preview page).",
      // backPreviewOff: "N/A (non-toggleable button).",
      downloadGuide: "Download All",
      downloadOn: "Downloads a ZIP file with preview and text-only images for all customized items.",
      //downloadOff: "N/A (non-toggleable button).",
      noSelection: "Please select at least one item.",
      close: "Close",
      choppingBoard: "Chopping Board (Coming Soon)",
      tongs: "Tongs (Coming Soon)",
      scissors: "Scissors (Coming Soon)",
      chooseKnives: "Choose your items",
      disclaimerTitle: "Disclaimer",
      disclaimerText: `
        The Knife Engraving Customizer allows you to preview and design personalized engravings on selected products. Please note the following:<br>
        • <strong>Preview Accuracy</strong>: The previews generated are for visualization purposes only and may differ slightly from the final engraved product due to variations in materials, engraving techniques, or device display settings.<br>
        • <strong>Content Responsibility</strong>: You are responsible for ensuring that the text entered is appropriate, non-offensive, and complies with applicable laws. We reserve the right to reject any engraving requests that contain inappropriate or prohibited content.<br>
        • <strong>Production Limitations</strong>: Engraving placement, size, and depth are subject to the physical constraints of the selected product and our engraving equipment. We will make reasonable efforts to match your design, but minor adjustments may be necessary.<br>
        • <strong>No Refunds for Customization</strong>: Due to the personalized nature of engraved products, orders are final and non-refundable unless the product is defective or the engraving significantly deviates from the approved design.<br>
        • <strong>Technical Issues</strong>: While we strive to ensure the tool functions correctly, we are not liable for errors caused by technical issues, such as browser compatibility or incorrect preview rendering.<br>
        By using this tool, you acknowledge and agree to these terms. For questions, contact our customer support.
      `
    },
    "zh-hk": {
      title: "刀具刻字定制器",
      subtitle: "由",
      subtitleAfter: "提供",
      next: "下一步",
      back: "返回",
      preview: "預覽",
      previewAllKnives: "預覽所有產品",
      previewDescription: "點擊任何圖片放大",
      download: "下載",
      chefKnife: "主廚刀",
      santokuKnife: "三德刀",
      breadKnife: "麵包刀",
      chopperKnife: "砍刀",
      utilityKnife: "多用途刀",
      paringKnife: "削皮刀",
      textLabel: "文字：",
      textPlaceholder: "輸入刻字",
      fontLabel: "字體：",
      sameContentLabel: "所有產品使用相同文字",
      instructions: "• 拖動文字以移動。<br>• 拖動角落以縮放（桌面）。<br>• 捏合以縮放和移動文字（手機）。",
      editZone: "編輯區域",
      resizeControls: "調整控制",
      syncFonts: "同步字體",
      autoAlignment: "自動對齊",
      loading: "載入中…",
      knife: "刀",
      english: "英文",
      chinese: "中文",
      modalClose: "點擊任意位置關閉",
      buttonGuideTitle: "如何使用控制按鈕",
      backCustomize: "返回",
      backCustomizeOn: "返回上一頁（例如產品選擇）。",
      //backCustomizeOff: "不適用（不可切換按鈕）。",
      editZoneGuide: "顯示編輯區域",
      editZoneOn: "開：顯示刻字區域覆蓋，指引文字放置。",
      editZoneOff: "關：隱藏刻字區域覆蓋，以更清晰地查看產品。",
      resizeControlsGuide: "顯示調整手柄",
      resizeControlsOn: "開：顯示角落手柄，可拖動調整文字大小和位置。",
      resizeControlsOff: "關：隱藏調整手柄，保持文字可編輯但視圖更簡潔。",
      syncFontsGuide: "同步文字樣式",
      syncFontsOn: "開：將相同的字體和大小應用於同一頁的所有產品。",
      syncFontsOff: "關：允許每份產品獨立使用不同的字體和大小。",
      autoAlignGuide: "自動對齊文字",
      autoAlignOn: "開：保持同一組產品的文字位置對齊，確保一致性。",
      autoAlignOff: "關：允許每件產品的文字位置獨立調整。",
      backPreview: "下一步",
      backPreviewOn: "前往下一頁（例如預覽頁面）。",
      //backPreviewOff: "不適用（不可切換按鈕）。",
      downloadGuide: "下載全部",
      downloadOn: "下載包含所有定制刀具預覽和純文字圖片的ZIP文件。",
      //downloadOff: "不適用（不可切換按鈕）。",
      noSelection: "請至少選擇一件產品。",
      close: "關閉",
      choppingBoard: "砧板（即將推出）",
      tongs: "夾子（即將推出）",
      scissors: "剪刀（即將推出）",
      chooseKnives: "選擇你的產品",
      disclaimerTitle: "免責聲明",
    disclaimerText: `
      刀具刻字定制器允許您預覽和設計所選產品的個性化刻字。請注意以下事項：<br>
      • <strong>預覽準確性</strong>：生成的預覽僅供視覺參考，可能因材料、刻字技術或設備顯示設置的差異，與最終刻字產品略有不同。<br>
      • <strong>內容責任</strong>：您有責任確保輸入的文字適當、無冒犯性並符合適用法律。我們保留拒絕任何包含不當或禁止內容的刻字請求的權利。<br>
      • <strong>生產限制</strong>：刻字的位置、大小和深度受所選產品和我們刻字設備的物理限制。我們會盡合理努力匹配您的設計，但可能需要輕微調整。<br>
      • <strong>定制產品無退貨</strong>：由於刻字產品的個性化特性，除非產品有缺陷或刻字與批准的設計顯著不符，否則訂單為最終確認且不可退貨。<br>
      • <strong>技術問題</strong>：雖然我們努力確保工具正常運行，但我們對因技術問題（例如瀏覽器兼容性或預覽渲染錯誤）導致的錯誤不承擔責任。<br>
      使用本工具即表示您認可並同意這些條款。如有疑問，請聯繫我們的客戶支持。
    `
    }
  };

  /* LANGUAGE TOGGLE */
  let currentLang = 'en';

  function updateLanguage(lang) {
    currentLang = lang;
    document.documentElement.lang = lang;
    const langToggleBtn = document.getElementById('lang-toggle');
    if (langToggleBtn) {
      langToggleBtn.textContent = lang === 'en' ? translations['zh-hk'].chinese : translations.en.english;
    }

    document.getElementById('title').textContent = translations[lang].title;
    const subtitle = document.getElementById('subtitle');
    subtitle.innerHTML = `${translations[lang].subtitle} <img src="kool-logo.png" alt="logo" style="width:50px;vertical-align:bottom;"> ${translations[lang].subtitleAfter}`;
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (translations[lang][key]) {
            if (el.tagName === 'INPUT' && el.type === 'text') {
                el.placeholder = translations[lang][key];
            } else if (el.id !== 'back-2' && el.id !== 'back-3' && el.id !== 'back-4' &&
                       el.id !== 'edit-zone' && el.id !== 'resize-controls' &&
                       el.id !== 'sync-fonts' && el.id !== 'auto-align' &&
                       el.id !== 'next-1' && el.id !== 'next-2' && el.id !== 'next-3' &&
                       el.id !== 'download-all') {
                el.innerHTML = translations[lang][key];
            }
        }
    });

    document.getElementById('alert-close').textContent = translations[lang].close;

    bigKnifeContent.innerHTML = '';
    smallKnifeContent.innerHTML = '';
    otherContent.innerHTML = '';
    const selectedKnives = Object.keys(state);
    selectedKnives.forEach(knife => {
      createCanvasSection(knife);
      initializeKnife(knife);
    });

    if (pages[4].classList.contains('active')) {
      generatePreviews();
    }
  }

  document.addEventListener('click', e => {
    if (e.target.id === 'lang-toggle' || e.target.closest('#lang-toggle')) {
      console.log('Language toggle clicked');
      updateLanguage(currentLang === 'en' ? 'zh-hk' : 'en');
    }
  });

  /* STATE */
  const knives = {
    big: ['santoku', 'chef', 'bread', 'chopper'],
    small: ['utility', 'paring'],
    others: ['choppingBoard', 'tongs', 'scissors']
  };
  const state = {};
  let sameContent = true;
  let sharedText = '';
  let firstSelectedKnife = null;
  let lastAdjusted = { big: null, small: null, others: null };
  let syncFonts = true;
  let showEditZone = true;
  let showResizeControls = true;
  let alignRightBig = true;
  let alignRightSmall = true;
  let alignRightOthers = true;
  let isNavigating = false;
  let lastToggleTime = 0;
  let lastBigKnifeFont = currentLang === 'zh-hk' ? "'Noto Sans HK',sans-serif" : "Montserrat";
  let storedPositions = { big: {}, small: {} }; // Store textRightX, pos.y for auto-align toggle
  const toggleDebounce = 200; // ms

  /* ELEMENTS */
  const pages = {
    1: document.getElementById('page-1'),
    2: document.getElementById('page-2'),
    3: document.getElementById('page-3'),
    4: document.getElementById('page-4'),
    5: document.getElementById('page-5')
  };
  const productPicker = document.getElementById('product-picker');
  const bigKnifeContent = document.getElementById('big-knife-content');
  const smallKnifeContent = document.getElementById('small-knife-content');
  const previewContent = document.getElementById('preview-content');
  const otherContent = document.getElementById('other-content');
  const next1Btn = document.getElementById('next-1');
  const back2Btn = document.getElementById('back-2');
  const next2Btn = document.getElementById('next-2');
  const back3Btn = document.getElementById('back-3');
  const next3Btn = document.getElementById('next-3');
  const back4Btn = document.getElementById('back-4');
  const back5Btn = document.getElementById('back-5');
  const next5Btn = document.getElementById('next-5');
  const downloadBtn = document.getElementById('download-all');
  const modal = document.getElementById('modal');
  const modalImage = document.getElementById('modal-image');

  /* HELPERS */
  function loadImage(src) {
    return new Promise((resolve, reject) => {
      const i = new Image();
      i.crossOrigin = 'anonymous';
      i.onload = () => resolve(i);
      i.onerror = () => reject(new Error(`Failed to load image: ${src}`));
      i.src = src;
    });
  }

  function fitInBox(canvas, img, wrapper) {
    const wrapW = wrapper.clientWidth;
    const scale = wrapW / img.naturalWidth;
    canvas.width = img.naturalWidth * scale;
    canvas.height = img.naturalHeight * scale;
    canvas.style.width = canvas.width + 'px';
    canvas.style.height = canvas.height + 'px';
    return scale;
  }

  function measureText(ctx, text, fontSize, font) {
    ctx.font = `${fontSize}px ${font}`;
    return { w: ctx.measureText(text).width, h: fontSize };
  }

  function toFullCoords(canvas, wrapper, cx, cy) {
    const r = canvas.getBoundingClientRect();
    return {
      x: (cx - r.left) * (wrapper.full.width / r.width),
      y: (cy - r.top) * (wrapper.full.height / r.height)
    };
  }

  function hitTest(fx, fy, posY, dims, scale, textRightX) {
    const x = textRightX - dims.w * scale;
    return fx >= x && fx <= textRightX &&
           fy >= posY && fy <= posY + dims.h * scale;
  }

  function hasBigKnives(selected) {
    return selected.some(input => knives.big.includes(input.dataset.name));
  }

  function hasSmallKnives(selected) {
    return selected.some(input => knives.small.includes(input.dataset.name));
  }
  
  function hasOtherItems(selected) {
    return selected.some(input => knives.others.includes(input.dataset.name));
  }

  function switchPage(from, to) {
    if (isNavigating) return;
    isNavigating = true;
    pages[from].classList.remove('active');
    pages[to].classList.add('active');
    window.scrollTo({ top: 0, behavior: 'smooth' });
    setTimeout(() => { isNavigating = false; }, 100);
  }

  function createCanvasSection(knife) {
    const showSameContent = knife === firstSelectedKnife;
    const section = document.createElement('div');
    section.className = 'knife-section';
    section.innerHTML = `
      <h3 data-i18n="${knives.big.includes(knife) || knives.small.includes(knife) ? knife + 'Knife' : knife}">${translations[currentLang][knives.big.includes(knife) || knives.small.includes(knife) ? knife + 'Knife' : knife]}</h3>
      <div class="controls">
        <div>
          <label for="text-${knife}" data-i18n="textLabel">${translations[currentLang].textLabel}</label>
          <input type="text" id="text-${knife}" placeholder="${translations[currentLang].textPlaceholder}">
        </div>
        <div>
          <label for="font-${knife}" data-i18n="fontLabel">${translations[currentLang].fontLabel}</label>
          <select id="font-${knife}" ${currentLang === 'zh-hk' ? 'data-default="Noto Sans HK"' : ''}>
            <optgroup label="${translations[currentLang].english}">
              <option value="Montserrat">Montserrat</option>
              <option value="Roboto">Roboto</option>
              <option value="Lobster">Lobster</option>
              <option value="'Times New Roman',serif">Times New Roman</option>
              <option value="'Courier New',monospace">Courier New</option>
              <option value="Arial,sans-serif">Arial</option>
            </optgroup>
            <optgroup label="${translations[currentLang].chinese}">
              <option value="'Chocolate Classical Sans',sans-serif">朱古力黑體</option>
              <option value="'LXGW WenKai Mono TC',monospace">霞鶩文楷</option>
              <option value="'Noto Sans HK',sans-serif">思源黑體</option>
              <option value="'Noto Serif TC',serif">思源宋體</option>
            </optgroup>
          </select>
        </div>
      </div>
      ${showSameContent ? `
        <div class="same-content">
          <input type="checkbox" id="same-content-${knife}" ${sameContent ? 'checked' : ''}>
          <label for="same-content-${knife}" data-i18n="sameContentLabel">${translations[currentLang].sameContentLabel}</label>
        </div>
      ` : ''}
      <p style="font-size:.8rem;color:#666;margin-top:.5rem;" data-i18n="instructions">
        ${translations[currentLang].instructions}
      </p>
      <div class="canvas-wrapper" id="wrapper-${knife}">
        <canvas id="canvas-${knife}"></canvas>
        <div class="loading-overlay" id="overlay-${knife}" data-i18n="loading">${translations[currentLang].loading}</div>
        <div class="bbox" id="bbox-${knife}">
          <div class="handle" data-handle="nw"></div>
          <div class="handle" data-handle="ne"></div>
          <div class="handle" data-handle="sw"></div>
          <div class="handle" data-handle="se"></div>
        </div>
      </div>
    `;
    if (knives.big.includes(knife)) {
      bigKnifeContent.appendChild(section);
    } else if (knives.small.includes(knife)) {
      smallKnifeContent.appendChild(section);
    } else if (knives.others.includes(knife)) {
      otherContent.appendChild(section);
    }

    state[knife] = {
      img: null,
      overlay: null,
      baseFont: knives.big.includes(knife) ? 150 : knives.small.includes(knife) ? 100 : 120,
      textScale: 1,
      baseDims: { w: 0, h: 0 },
      textRightX: 0, // Set to canvas center after image load
      pos: { y: 0 }, // Set to canvas center after image load
      boxVisible: showResizeControls,
      dragging: false,
      dragStart: {},
      resizing: false,
      resizeStart: {},
      pointers: {},
      pinch: false,
      pinchStart: {},
      view: document.getElementById(`canvas-${knife}`),
      vCtx: document.getElementById(`canvas-${knife}`).getContext('2d'),
      full: document.createElement('canvas'),
      fCtx: document.createElement('canvas').getContext('2d'),
      wrapper: document.getElementById(`wrapper-${knife}`),
      overlayEl: document.getElementById(`overlay-${knife}`),
      bbox: document.getElementById(`bbox-${knife}`),
      textInput: document.getElementById(`text-${knife}`),
      fontSel: document.getElementById(`font-${knife}`),
      sameContentChk: showSameContent ? document.getElementById(`same-content-${knife}`) : null,
      cacheCanvas: document.createElement('canvas'),
      cacheCtx: document.createElement('canvas').getContext('2d'),
      textCacheCanvas: document.createElement('canvas'),
      textCacheCtx: document.createElement('canvas').getContext('2d'),
      previewCanvas: document.createElement('canvas'),
      cacheValid: false,
      textCacheValid: false,
      pendingDraw: false // Added for draw optimization
    };
    state[knife].full.width = 0;
    state[knife].full.height = 0;
    state[knife].fCtx = state[knife].full.getContext('2d');
    state[knife].cacheCanvas.width = 0;
    state[knife].cacheCanvas.height = 0;
    state[knife].cacheCtx = state[knife].cacheCanvas.getContext('2d');
    state[knife].textCacheCanvas.width = 0;
    state[knife].textCacheCanvas.height = 0;
    state[knife].textCacheCtx = state[knife].textCacheCanvas.getContext('2d');
    state[knife].previewCanvas.width = 0;
    state[knife].previewCanvas.height = 0;
  }

  function draw(knife) {
    const s = state[knife];
    if (!s.img || s.full.width === 0 || s.full.height === 0) return;
  
    const textX = s.textRightX;
  
    // Cache base image and overlay
    if (!s.cacheValid) {
      s.cacheCanvas.width = s.full.width;
      s.cacheCanvas.height = s.full.height;
      if (s.cacheCanvas.width === 0 || s.cacheCanvas.height === 0) return;
      s.cacheCtx.clearRect(0, 0, s.full.width, s.full.height);
      s.cacheCtx.drawImage(s.img, 0, 0);
      if (showEditZone && s.overlay) {
        s.cacheCtx.drawImage(s.overlay, 0, 0, s.full.width, s.full.height);
      }
      s.cacheValid = true;
    }
  
    // Cache text
    if (!s.textCacheValid) {
      s.textCacheCanvas.width = s.full.width;
      s.textCacheCanvas.height = s.full.height;
      if (s.textCacheCanvas.width === 0 || s.textCacheCanvas.height === 0) return;
      s.textCacheCtx.clearRect(0, 0, s.full.width, s.full.height);
      if (s.textInput.value) {
        s.textCacheCtx.font = `${s.baseFont * s.textScale}px ${s.fontSel.value}`;
        s.textCacheCtx.fillStyle = '#000';
        s.textCacheCtx.textBaseline = 'top';
        s.textCacheCtx.textAlign = 'right';
        s.textCacheCtx.fillText(s.textInput.value, textX, s.pos.y);
      }
      s.textCacheValid = true;
    }
  
    // Full-res canvas
    s.fCtx.clearRect(0, 0, s.full.width, s.full.height);
    s.fCtx.drawImage(s.cacheCanvas, 0, 0);
    s.fCtx.drawImage(s.textCacheCanvas, 0, 0);
  
    // Preview canvas
    const scale = s.view.width / s.full.width;
    s.vCtx.imageSmoothingEnabled = true;
    s.vCtx.imageSmoothingQuality = 'high';
    s.vCtx.setTransform(scale, 0, 0, scale, 0, 0);
    s.vCtx.clearRect(0, 0, s.full.width, s.full.height);
    s.vCtx.drawImage(s.cacheCanvas, 0, 0);
    s.vCtx.drawImage(s.textCacheCanvas, 0, 0);
    s.vCtx.setTransform(1, 0, 0, 1, 0, 0);
  
    // Bounding box (left edge at textRightX - width)
    const dx = s.view.width / s.full.width;
    const dy = s.view.height / s.full.height;
    if (s.boxVisible && s.textInput.value) {
      s.bbox.style.display = 'block';
      s.bbox.style.width = (s.baseDims.w * s.textScale * dx) + 'px';
      s.bbox.style.height = (s.baseDims.h * s.textScale * dy) + 'px';
      s.bbox.style.left = ((textX - s.baseDims.w * s.textScale) * dx) + 'px';
      s.bbox.style.top = (s.pos.y * dy) + 'px';
    } else {
      s.bbox.style.display = 'none';
    }
    s.pendingDraw = false;
  }

  function invalidateCache(knife) {
    state[knife].cacheValid = false;
  }

  function invalidateTextCache(knife) {
    state[knife].textCacheValid = false;
  }

  function syncFontAndText(knife) {
    if (!syncFonts) return;
    const refState = state[knife];
    const fontFamily = refState.fontSel.value;
    const effectiveFontSize = refState.baseFont * refState.textScale;
    const isBigKnife = knives.big.includes(knife);
    const isSmallKnife = knives.small.includes(knife);
    const isOtherItem = knives.others.includes(knife);
    Object.keys(state).forEach(k => {
      if (k !== knife && 
          ((isBigKnife && knives.big.includes(k)) || 
           (isSmallKnife && knives.small.includes(k)) || 
           (isOtherItem && knives.others.includes(k)))) {
        state[k].fontSel.value = fontFamily;
        state[k].baseFont = effectiveFontSize;
        state[k].textScale = 1;
        state[k].baseDims = measureText(state[k].fCtx, state[k].textInput.value, state[k].baseFont, state[k].fontSel.value);
        invalidateTextCache(k);
        if (!state[k].pendingDraw) {
          state[k].pendingDraw = true;
          requestAnimationFrame(() => draw(k));
        }
      }
    });
    if (isBigKnife) {
      lastBigKnifeFont = fontFamily;
    }
  }

  function debounceToggle(fn, id, icon) {
    return () => {
      const now = Date.now();
      if (now - lastToggleTime < toggleDebounce) return;
      lastToggleTime = now;
      console.log(`Toggling ${id}`);
      fn();
      document.querySelectorAll(`#${id}`).forEach(btn => {
        btn.innerHTML = `<span class="material-symbols-outlined">${icon}</span>`;
      });
    };
  }

  function toggleEditZone() {
    showEditZone = !showEditZone;
    Object.keys(state).forEach(knife => {
      invalidateCache(knife);
      if (!state[knife].pendingDraw) {
        state[knife].pendingDraw = true;
        requestAnimationFrame(() => draw(knife));
      }
    });
    document.querySelectorAll('#edit-zone').forEach(btn => {
      btn.classList.toggle('off', !showEditZone);
    });
  }

  function toggleResizeControls() {
    showResizeControls = !showResizeControls;
    Object.keys(state).forEach(knife => {
      state[knife].boxVisible = showResizeControls;
      if (!state[knife].pendingDraw) {
        state[knife].pendingDraw = true;
        requestAnimationFrame(() => draw(knife));
      }
    });
    document.querySelectorAll('#resize-controls').forEach(btn => {
      btn.classList.toggle('off', !showResizeControls);
    });
  }

  function toggleSyncFonts() {
    syncFonts = !syncFonts;
    if (syncFonts && Object.keys(state).length > 0) {
      const bigKnife = lastAdjusted.big || Object.keys(state).find(k => knives.big.includes(k));
      const smallKnife = lastAdjusted.small || Object.keys(state).find(k => knives.small.includes(k));
      if (bigKnife) syncFontAndText(bigKnife);
      if (smallKnife) syncFontAndText(smallKnife);
    }
    document.querySelectorAll('#sync-fonts').forEach(btn => {
      btn.classList.toggle('off', !syncFonts);
    });
  }

  function toggleAlignment(knife) {
    const isBigKnife = knives.big.includes(knife);
    const isSmallKnife = knives.small.includes(knife);
    const isOtherItem = knives.others.includes(knife);
    const alignRight = isBigKnife ? alignRightBig : isSmallKnife ? alignRightSmall : alignRightOthers;
    const group = isBigKnife ? 'big' : isSmallKnife ? 'small' : 'others';
  
    if (alignRight) {
      // Turning off: Keep current positions
      Object.keys(state).forEach(k => {
        if ((isBigKnife && knives.big.includes(k)) || 
            (isSmallKnife && knives.small.includes(k)) || 
            (isOtherItem && knives.others.includes(k))) {
          storedPositions[group][k] = { textRightX: state[k].textRightX, y: state[k].pos.y };
          invalidateTextCache(k);
          if (!state[k].pendingDraw) {
            state[k].pendingDraw = true;
            requestAnimationFrame(() => draw(k));
          }
        }
      });
      if (isBigKnife) alignRightBig = false;
      else if (isSmallKnife) alignRightSmall = false;
      else alignRightOthers = false;
    } else {
      // Turning on: Sync to last adjusted item's right edge
      const lastKnife = lastAdjusted[group] || knife;
      const refTextRightX = state[lastKnife].textRightX;
      const refY = state[lastKnife].pos.y;
      Object.keys(state).forEach(k => {
        if ((isBigKnife && knives.big.includes(k)) || 
            (isSmallKnife && knives.small.includes(k)) || 
            (isOtherItem && knives.others.includes(k))) {
          storedPositions[group][k] = { textRightX: state[k].textRightX, y: state[k].pos.y };
          state[k].textRightX = refTextRightX;
          state[k].pos.y = refY;
          invalidateTextCache(k);
          if (!state[k].pendingDraw) {
            state[k].pendingDraw = true;
            requestAnimationFrame(() => draw(k));
          }
        }
      });
      if (isBigKnife) alignRightBig = true;
      else if (isSmallKnife) alignRightSmall = true;
      else alignRightOthers = true;
    }
  
    document.querySelectorAll('#auto-align').forEach(btn => {
      btn.classList.toggle('off', isBigKnife ? !alignRightBig : isSmallKnife ? !alignRightSmall : !alignRightOthers);
    });
  }

  async function generatePreviews() {
    previewContent.innerHTML = '';
    for (const knife of Object.keys(state)) {
      const s = state[knife];
      s.previewCanvas.width = s.full.width;
      s.previewCanvas.height = s.full.height;
      const ctx = s.previewCanvas.getContext('2d');
      ctx.drawImage(s.img, 0, 0);
      if (s.textInput.value) {
        ctx.font = `${s.baseFont * s.textScale}px ${s.fontSel.value}`;
        ctx.fillStyle = '#000';
        ctx.textBaseline = 'top';
        ctx.textAlign = 'right';
        ctx.fillText(s.textInput.value, s.textRightX, s.pos.y);
      }
      const previewUrl = s.previewCanvas.toDataURL('image/png');
      const div = document.createElement('div');
      div.className = 'preview-item';
      div.innerHTML = `
        <img src="${previewUrl}" alt="${knife} preview" data-knife="${knife}">
        <span data-i18n="${knife}Knife">${translations[currentLang][`${knife}Knife`]}</span>
      `;
      previewContent.appendChild(div);
    }
    previewContent.querySelectorAll('img').forEach(img => {
      img.addEventListener('click', () => {
        modalImage.src = img.src;
        modal.style.display = 'flex';
      });
    });
  }

  modal.addEventListener('click', () => {
    modal.style.display = 'none';
    modalImage.src = '';
  });

  const alertModal = document.getElementById('alert-modal');
  const alertCloseBtn = document.getElementById('alert-close');
  
  alertCloseBtn.addEventListener('click', () => {
      alertModal.style.display = 'none';
      document.getElementById('alert-message').textContent = '';
  });  

  document.fonts.ready.then(() => {
    Object.keys(state).forEach(knife => {
      if (!state[knife].pendingDraw) {
        state[knife].pendingDraw = true;
        requestAnimationFrame(() => draw(knife));
      }
    });
  });

  next1Btn.addEventListener('click', async () => {
    if (isNavigating) return;
    const selected = Array.from(productPicker.querySelectorAll('input:checked'));
    if (selected.length === 0) {
      const alertModal = document.getElementById('alert-modal');
      const alertMessage = document.getElementById('alert-message');
      alertMessage.textContent = translations[currentLang].noSelection;
      alertModal.style.display = 'flex';
      return;
    }
    bigKnifeContent.innerHTML = '';
    smallKnifeContent.innerHTML = '';
    otherContent.innerHTML = '';
    Object.keys(state).forEach(knife => delete state[knife]);
    firstSelectedKnife = selected[0].dataset.name;
  
    const hasBig = hasBigKnives(selected);
    const hasSmall = hasSmallKnives(selected);
    const hasOthers = hasOtherItems(selected);
  
    if (hasBig) {
      switchPage(1, 2);
      for (const input of selected) {
        const knife = input.dataset.name;
        if (knives.big.includes(knife)) {
          await initializeKnife(knife);
        }
      }
    } else if (hasSmall) {
      switchPage(1, 3);
      for (const input of selected) {
        const knife = input.dataset.name;
        if (knives.small.includes(knife)) {
          await initializeKnife(knife);
        }
      }
    } else if (hasOthers) {
      switchPage(1, 5);
      for (const input of selected) {
        const knife = input.dataset.name;
        if (knives.others.includes(knife)) {
          await initializeKnife(knife);
        }
      }
    }
  });

  back2Btn.addEventListener('click', () => {
    switchPage(2, 1);
  });

  next2Btn.addEventListener('click', async () => {
    if (isNavigating) return;
    const selected = Array.from(productPicker.querySelectorAll('input:checked'));
    const hasSmall = hasSmallKnives(selected);
    const hasOthers = hasOtherItems(selected);
    if (hasSmall) {
      switchPage(2, 3);
      for (const input of selected) {
        const knife = input.dataset.name;
        if (knives.small.includes(knife) && !state[knife]) {
          await initializeKnife(knife);
        }
      }
    } else if (hasOthers) {
      switchPage(2, 5);
      for (const input of selected) {
        const knife = input.dataset.name;
        if (knives.others.includes(knife) && !state[knife]) {
          await initializeKnife(knife);
        }
      }
    } else {
      switchPage(2, 4);
      await generatePreviews();
    }
  });

  back3Btn.addEventListener('click', () => {
    const selected = Array.from(productPicker.querySelectorAll('input:checked'));
    const hasBig = hasBigKnives(selected);
    if (hasBig) {
      switchPage(3, 2);
    } else {
      switchPage(3, 1);
    }
  });

  next3Btn.addEventListener('click', async () => {
    if (isNavigating) return;
    const selected = Array.from(productPicker.querySelectorAll('input:checked'));
    const hasOthers = hasOtherItems(selected);
    if (hasOthers) {
      switchPage(3, 5);
      for (const input of selected) {
        const knife = input.dataset.name;
        if (knives.others.includes(knife) && !state[knife]) {
          await initializeKnife(knife);
        }
      }
    } else {
      switchPage(3, 4);
      await generatePreviews();
    }
  });

  back4Btn.addEventListener('click', () => {
    const selected = Array.from(productPicker.querySelectorAll('input:checked'));
    const hasOthers = hasOtherItems(selected);
    const hasSmall = hasSmallKnives(selected);
    const hasBig = hasBigKnives(selected);
    if (hasOthers) {
      switchPage(4, 5);
    } else if (hasSmall) {
      switchPage(4, 3);
    } else if (hasBig) {
      switchPage(4, 2);
    } else {
      switchPage(4, 1);
    }
  });

    

  back5Btn.addEventListener('click', () => {
    const selected = Array.from(productPicker.querySelectorAll('input:checked'));
    const hasSmall = hasSmallKnives(selected);
    const hasBig = hasBigKnives(selected);
    if (hasSmall) {
      switchPage(5, 3);
    } else if (hasBig) {
      switchPage(5, 2);
    } else {
      switchPage(5, 1);
    }
  });
  
  next5Btn.addEventListener('click', async () => {
    if (isNavigating) return;
    switchPage(5, 4);
    await generatePreviews();
  });

  document.addEventListener('click', e => {
    if (e.target.id === 'edit-zone' || e.target.closest('#edit-zone')) {
      debounceToggle(toggleEditZone, 'edit-zone', 'vignette')();
    } else if (e.target.id === 'resize-controls' || e.target.closest('#resize-controls')) {
      debounceToggle(toggleResizeControls, 'resize-controls', 'format_shapes')();
    } else if (e.target.id === 'sync-fonts' || e.target.closest('#sync-fonts')) {
      debounceToggle(toggleSyncFonts, 'sync-fonts', 'format_size')();
    } else if (e.target.id === 'auto-align' || e.target.closest('#auto-align')) {
      const activePage = Object.keys(pages).find(p => pages[p].classList.contains('active'));
      const knife = activePage === '2' ? Object.keys(state).find(k => knives.big.includes(k)) :
                    activePage === '3' ? Object.keys(state).find(k => knives.small.includes(k)) :
                    activePage === '5' ? Object.keys(state).find(k => knives.others.includes(k)) : null;
      if (knife) {
        debounceToggle(() => toggleAlignment(knife), 'auto-align', 'recenter')();
      }
    }
  });

  async function initializeKnife(knife) {
    createCanvasSection(knife);
    const s = state[knife];
    s.overlayEl.style.visibility = 'visible';
    s.img = await loadImage(
      productPicker.querySelector(`input[data-name="${knife}"]`).value
    );
    try {
      s.overlay = await loadImage(`${knife}-overlay.png`);
    } catch (e) {
      console.warn(`Overlay image for ${knife} not found`);
      s.overlay = null;
    }
    s.full.width = s.img.naturalWidth;
    s.full.height = s.img.naturalHeight;
    // Center text
    s.textRightX = s.full.width / 2;
    s.pos.y = s.full.height / 2;
    s.cacheCanvas.width = s.full.width;
    s.cacheCanvas.height = s.full.height;
    s.textCacheCanvas.width = s.full.width;
    s.textCacheCanvas.height = s.full.height;
    s.previewCanvas.width = s.full.width;
    s.previewCanvas.height = s.full.height;
    fitInBox(s.view, s.img, s.wrapper);
    const isBigKnife = knives.big.includes(knife);
    s.fontSel.value = isBigKnife ? lastBigKnifeFont : lastBigKnifeFont;
    s.baseDims = { w: 0, h: s.baseFont };

    if (sameContent && sharedText) {
      s.textInput.value = sharedText;
      s.baseDims = measureText(s.fCtx, s.textInput.value, s.baseFont, s.fontSel.value);
    }

    await document.fonts.load(`${s.baseFont}px ${s.fontSel.value}`);
    if (s.textInput.value) {
      s.baseDims = measureText(s.fCtx, s.textInput.value, s.baseFont, s.fontSel.value);
    }
    s.overlayEl.style.visibility = 'hidden';
    if (!s.pendingDraw) {
      s.pendingDraw = true;
      requestAnimationFrame(() => draw(knife));
    }

    s.textInput.addEventListener('input', () => {
      if (sameContent) {
        sharedText = s.textInput.value;
        Object.keys(state).forEach(k => {
          state[k].textInput.value = sharedText;
          state[k].baseDims = measureText(state[k].fCtx, state[k].textInput.value, state[k].baseFont, state[k].fontSel.value);
          invalidateTextCache(k);
          if (!state[k].pendingDraw) {
            state[k].pendingDraw = true;
            requestAnimationFrame(() => draw(k));
          }
        });
      } else {
        s.baseDims = measureText(s.fCtx, s.textInput.value, s.baseFont, s.fontSel.value);
        invalidateTextCache(knife);
        if (!s.pendingDraw) {
          s.pendingDraw = true;
          requestAnimationFrame(() => draw(knife));
        }
      }
      lastAdjusted[knives.big.includes(knife) ? 'big' : 'small'] = knife;
    });

    s.fontSel.addEventListener('input', () => {
      document.fonts.load(`${s.baseFont}px ${s.fontSel.value}`).then(() => {
        s.baseDims = measureText(s.fCtx, s.textInput.value, s.baseFont, s.fontSel.value);
        invalidateTextCache(knife);
        if (!s.pendingDraw) {
          s.pendingDraw = true;
          requestAnimationFrame(() => draw(knife));
        }
        syncFontAndText(knife);
        lastAdjusted[knives.big.includes(knife) ? 'big' : 'small'] = knife;
      });
    });

    if (s.sameContentChk) {
      s.sameContentChk.addEventListener('change', () => {
        sameContent = s.sameContentChk.checked;
        if (sameContent) {
          sharedText = s.textInput.value;
          Object.keys(state).forEach(k => {
            state[k].textInput.value = sharedText;
            state[k].baseDims = measureText(state[k].fCtx, state[k].textInput.value, state[k].baseFont, state[k].fontSel.value);
            invalidateTextCache(k);
            if (!state[k].pendingDraw) {
              state[k].pendingDraw = true;
              requestAnimationFrame(() => draw(k));
            }
          });
        } else {
          sharedText = '';
        }
      });
    }

    // Dragging
    s.view.addEventListener('pointerdown', e => {
      const f = toFullCoords(s.view, s, e.clientX, e.clientY);
      if (!hitTest(f.x, f.y, s.pos.y, s.baseDims, s.textScale, s.textRightX) || s.resizing) return;
      // console.log(`Dragging started for ${knife}`);
      s.dragging = true;
      s.dragStart = { id: e.pointerId, dx: f.x - s.textRightX, dy: f.y - s.pos.y };
      e.preventDefault();
    });

    window.addEventListener('pointermove', e => {
      if (!s.dragging || e.pointerId !== s.dragStart.id) return;
      const f = toFullCoords(s.view, s, e.clientX, e.clientY);
      s.textRightX = f.x - s.dragStart.dx;
      s.pos.y = f.y - s.dragStart.dy;
      const isBigKnife = knives.big.includes(knife);
      const alignRight = isBigKnife ? alignRightBig : alignRightSmall;
      if (alignRight) {
        Object.keys(state).forEach(k => {
          if (k !== knife && knives.big.includes(k) === isBigKnife) {
            state[k].textRightX = s.textRightX;
            state[k].pos.y = s.pos.y;
            invalidateTextCache(k);
            if (!state[k].pendingDraw) {
              state[k].pendingDraw = true;
              requestAnimationFrame(() => draw(k));
            }
          }
        });
      }
      invalidateTextCache(knife);
      if (!s.pendingDraw) {
        s.pendingDraw = true;
        requestAnimationFrame(() => draw(knife));
      }
      lastAdjusted[knives.big.includes(knife) ? 'big' : 'small'] = knife;
    });

    ['pointerup', 'pointercancel'].forEach(evt =>
      window.addEventListener(evt, e => {
        if (e.pointerId === s.dragStart.id) {
          // console.log(`Dragging stopped for ${knife}`);
          s.dragging = false;
        }
      })
    );

    // Resizing
    s.bbox.querySelectorAll('.handle').forEach(h => {
      h.addEventListener('pointerdown', e => {
        e.stopPropagation();
        // console.log(`Resizing started for ${knife}`);
        s.resizing = true;
        const handle = h.dataset.handle;
        const box = s.bbox.getBoundingClientRect();
        let anchorX, anchorY;
        // Anchor opposite corner
        if (handle === 'se') {
          anchorX = toFullCoords(s.view, s, box.left, box.top).x; // nw
          anchorY = toFullCoords(s.view, s, box.left, box.top).y;
        } else if (handle === 'nw') {
          anchorX = toFullCoords(s.view, s, box.right, box.bottom).x; // se
          anchorY = toFullCoords(s.view, s, box.right, box.bottom).y;
        } else if (handle === 'ne') {
          anchorX = toFullCoords(s.view, s, box.left, box.bottom).x; // sw
          anchorY = toFullCoords(s.view, s, box.left, box.bottom).y;
        } else if (handle === 'sw') {
          anchorX = toFullCoords(s.view, s, box.right, box.top).x; // ne
          anchorY = toFullCoords(s.view, s, box.right, box.top).y;
        }
        const p0 = toFullCoords(s.view, s, e.clientX, e.clientY);
        s.resizeStart = {
          id: e.pointerId,
          anchorX,
          anchorY,
          scale: s.textScale,
          textRightX: s.textRightX,
          posY: s.pos.y,
          handle
        };
      });
    });

    window.addEventListener('pointermove', e => {
      if (!s.resizing || e.pointerId !== s.resizeStart.id) return;
      const p = toFullCoords(s.view, s, e.clientX, e.clientY);
      const isBigKnife = knives.big.includes(knife);
      const alignRight = isBigKnife ? alignRightBig : alignRightSmall;
      let newScale;
      if (s.resizeStart.handle === 'se') {
        const dx = Math.abs(p.x - s.resizeStart.anchorX);
        const dy = Math.abs(p.y - s.resizeStart.anchorY);
        newScale = Math.max(dx / s.baseDims.w, dy / s.baseDims.h) || s.resizeStart.scale;
        s.textRightX = s.resizeStart.anchorX + s.baseDims.w * newScale;
        s.pos.y = s.resizeStart.anchorY;
      } else if (s.resizeStart.handle === 'nw') {
        const dx = Math.abs(s.resizeStart.anchorX - p.x);
        const dy = Math.abs(s.resizeStart.anchorY - p.y);
        newScale = Math.max(dx / s.baseDims.w, dy / s.baseDims.h) || s.resizeStart.scale;
        s.textRightX = s.resizeStart.anchorX;
        s.pos.y = s.resizeStart.anchorY - s.baseDims.h * newScale;
      } else if (s.resizeStart.handle === 'ne') {
        const dx = Math.abs(p.x - s.resizeStart.anchorX);
        const dy = Math.abs(p.y - s.resizeStart.anchorY);
        newScale = Math.max(dx / s.baseDims.w, dy / s.baseDims.h) || s.resizeStart.scale;
        s.textRightX = s.resizeStart.anchorX + s.baseDims.w * newScale;
        s.pos.y = s.resizeStart.anchorY - s.baseDims.h * newScale;
      } else if (s.resizeStart.handle === 'sw') {
        const dx = Math.abs(s.resizeStart.anchorX - p.x);
        const dy = Math.abs(p.y - s.resizeStart.anchorY);
        newScale = Math.max(dx / s.baseDims.w, dy / s.baseDims.h) || s.resizeStart.scale;
        s.textRightX = s.resizeStart.anchorX;
        s.pos.y = s.resizeStart.anchorY;
      }
      s.textScale = newScale;
      if (alignRight) {
        Object.keys(state).forEach(k => {
          if (k !== knife && knives.big.includes(k) === isBigKnife) {
            state[k].textRightX = s.textRightX;
            state[k].pos.y = s.pos.y;
            if (syncFonts) {
              state[k].baseFont = s.baseFont * s.textScale;
              state[k].textScale = 1;
              state[k].baseDims = measureText(state[k].fCtx, state[k].textInput.value, state[k].baseFont, state[k].fontSel.value);
            }
            invalidateTextCache(k);
            if (!state[k].pendingDraw) {
              state[k].pendingDraw = true;
              requestAnimationFrame(() => draw(k));
            }
          }
        });
      }
      if (syncFonts) {
        syncFontAndText(knife);
      }
      invalidateTextCache(knife);
      if (!s.pendingDraw) {
        s.pendingDraw = true;
        requestAnimationFrame(() => draw(knife));
      }
      lastAdjusted[knives.big.includes(knife) ? 'big' : 'small'] = knife;
    });

    ['pointerup', 'pointercancel'].forEach(evt =>
      window.addEventListener(evt, e => {
        if (e.pointerId === s.resizeStart.id) {
          // console.log(`Resizing stopped for ${knife}`);
          s.resizing = false;
        }
      })
    );

    // Pinching
    s.view.addEventListener('pointerdown', e => {
      s.pointers[e.pointerId] = { x: e.clientX, y: e.clientY };
      if (Object.keys(s.pointers).length === 2 && !s.dragging && !s.resizing) {
        // console.log(`Pinch started for ${knife}`);
        s.pinch = true;
        const [pA, pB] = Object.values(s.pointers);
        const fA = toFullCoords(s.view, s, pA.x, pA.y);
        const fB = toFullCoords(s.view, s, pB.x, pB.y);
        s.pinchStart = {
          scale: s.textScale,
          cx: (fA.x + fB.x) / 2,
          cy: (fA.y + fB.y) / 2,
          d0: Math.hypot(fA.x - fB.x, fA.y - fB.y)
        };
      }
    });

    window.addEventListener('pointermove', e => {
      if (!s.pinch || !(e.pointerId in s.pointers)) return;
      s.pointers[e.pointerId] = { x: e.clientX, y: e.clientY };
      const [a, b] = Object.values(s.pointers);
      const fA = toFullCoords(s.view, s, a.x, a.y);
      const fB = toFullCoords(s.view, s, b.x, b.y);
      const d1 = Math.hypot(fA.x - fB.x, fA.y - fB.y);
      s.textScale = s.pinchStart.scale * (d1 / s.pinchStart.d0);
      s.textRightX = (fA.x + fB.x) / 2;
      s.pos.y = (fA.y + fB.y) / 2 - (s.baseDims.h * s.textScale) / 2;
      const isBigKnife = knives.big.includes(knife);
      const alignRight = isBigKnife ? alignRightBig : alignRightSmall;
      if (alignRight) {
        Object.keys(state).forEach(k => {
          if (k !== knife && knives.big.includes(k) === isBigKnife) {
            state[k].textRightX = s.textRightX;
            state[k].pos.y = s.pos.y;
            if (syncFonts) {
              state[k].baseFont = s.baseFont * s.textScale;
              state[k].textScale = 1;
              state[k].baseDims = measureText(state[k].fCtx, state[k].textInput.value, state[k].baseFont, state[k].fontSel.value);
            }
            invalidateTextCache(k);
            if (!state[k].pendingDraw) {
              state[k].pendingDraw = true;
              requestAnimationFrame(() => draw(k));
            }
          }
        });
      }
      if (syncFonts) {
        syncFontAndText(knife);
      }
      invalidateTextCache(knife);
      if (!s.pendingDraw) {
        s.pendingDraw = true;
        requestAnimationFrame(() => draw(knife));
      }
      lastAdjusted[knives.big.includes(knife) ? 'big' : 'small'] = knife;
    });

    ['pointerup', 'pointercancel'].forEach(evt =>
      window.addEventListener(evt, e => {
        delete s.pointers[e.pointerId];
        if (Object.keys(s.pointers).length < 2) {
          // console.log(`Pinch stopped for ${knife}`);
          s.pinch = false;
          // Ensure final draw with updated state
          if (!s.pendingDraw) {
            s.pendingDraw = true;
            requestAnimationFrame(() => draw(knife));
          }
        }
      })
    );

    s.overlayEl.style.visibility = 'hidden';
  }

  downloadBtn.addEventListener('click', async () => {
    const zip = new JSZip();
    for (const knife of Object.keys(state)) {
      const s = state[knife];
      const previewBlob = await new Promise(r => s.previewCanvas.toBlob(r));
      zip.file(`${knife}-preview.png`, previewBlob);

      const t = document.createElement('canvas');
      t.width = s.full.width;
      t.height = s.full.height;
      const tCtx = t.getContext('2d');
      tCtx.font = `${s.baseFont * s.textScale}px ${s.fontSel.value}`;
      tCtx.fillStyle = '#000';
      tCtx.textBaseline = 'top';
      tCtx.textAlign = 'right';
      tCtx.fillText(s.textInput.value, s.textRightX, s.pos.y);
      const textBlob = await new Promise(r => t.toBlob(r));
      zip.file(`${knife}-text-only.png`, textBlob);
    }

    const zipBlob = await zip.generateAsync({ type: 'blob' });
    const url = URL.createObjectURL(zipBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'knife-engravings.zip';
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(url);
      a.remove();
    }, 100);
  });

  updateLanguage(currentLang);

  // Set initial button states
  document.querySelectorAll('#edit-zone').forEach(btn => btn.classList.remove('off'));
  document.querySelectorAll('#resize-controls').forEach(btn => btn.classList.remove('off'));
  document.querySelectorAll('#sync-fonts').forEach(btn => btn.classList.remove('off'));
  document.querySelectorAll('#auto-align').forEach(btn => btn.classList.remove('off'));
</script>
</body>
</html>
