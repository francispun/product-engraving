<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
  <title>Knife Engraving Customizer</title>
  <link rel="icon" type="image/x-icon" href="./favicon.ico">

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&family=Roboto:wght@400;700;900&family=Lobster&family=Chocolate+Classical+Sans&family=LXGW+WenKai+Mono+TC&family=Noto+Sans+HK:wght@400;700;900&family=Noto+Serif+TC:wght@400;700;900&display=swap" rel="stylesheet">

  <!-- Material Symbols -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

  <!-- JSZip for ZIP download -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <style>
    :root {
      --accent: #d00024;
      --gray: #888;
      --bg: #fafafa;
      --border: #ddd;
      --pad: 2rem;
      --radius: .5rem;
      --mpad: 1rem;
    }
    * {
      box-sizing: border-box;
      margin: 0;
    }
    body {
      font-family: Roboto, 'Noto Sans HK', Arial, sans-serif;
      background: #474a51;
      color: #ffffff;
      padding-bottom: 60px;
    }
    h1, h2, h3 {
      text-align: center;
      margin: 1rem 0;
    }
    h3 {
      margin-bottom: 1rem;
    }
    .container {
      max-width: 1200px;
      margin: auto;
      padding: var(--pad);
      display: flex;
      flex-direction: column;
      gap: var(--pad);
    }
    .page {
      display: none;
    }
    .page.active {
      display: block;
    }
    .section {
      background: #fff;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--pad);
    }
    #product-picker {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      padding-bottom: 4rem;
    }
    .product-option {
      position: relative;
      text-align: center;
      height: 210px;
      display: grid;
      align-items: center;
      justify-content: center;
    }
    .product-option input {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }
    .product-option img {
      max-width: 100%;
      max-height: 210px;
      object-fit: contain;
      border: 2px solid transparent;
      border-radius: var(--radius);
      display: block;
    }
    .product-option input:checked+img {
      border-color: var(--accent);
      border-width: medium;
    }
    .product-option span {
      display: block;
      font-size: .9rem;
      margin-top: .25rem;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
    }
    .controls label {
      font-size: .9rem;
      margin-right: .25rem;
    }
    .controls input[type="text"] {
      width: 250px;
      height: 33px;
      padding: .5rem;
      border: 1px solid var(--border);
      border-radius: var(--radius);
    }
    .controls select {
      height: 33px;
      border-radius: 7px;
    }
    .controls select[id^="weight-"] {
      width: 120px;
    }
    .canvas-wrapper {
      position: relative;
      width: 100%;
      max-width: 1168px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: #eaeaea;
      overflow: hidden;
      touch-action: none;
      margin: auto;
    }
    .canvas-wrapper canvas {
      border-radius: var(--radius);
    }
    canvas {
      display: block;
      touch-action: none;
    }
    .loading-overlay {
      position: absolute;
      inset: 0;
      background: rgba(255,255,255,0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      color: #555;
      visibility: hidden;
      z-index: 10;
    }
    .bbox {
      position: absolute;
      border: 1px dashed #000;
      pointer-events: none;
      display: none;
      z-index: 30;
    }
    .handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #fff;
      border: 1px solid #000;
      pointer-events: auto;
      z-index: 31;
    }
    .handle[data-handle="nw"] {
      top: -5px;
      left: -5px;
      cursor: nwse-resize;
    }
    .handle[data-handle="ne"] {
      top: -5px;
      right: -5px;
      cursor: nesw-resize;
    }
    .handle[data-handle="sw"] {
      bottom: -5px;
      left: -5px;
      cursor: nesw-resize;
    }
    .handle[data-handle="se"] {
      bottom: -5px;
      right: -5px;
      cursor: nwse-resize;
    }
    button {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: .6rem;
      border-radius: var(--radius);
      cursor: pointer;
      font-weight: 600;
      font-size: 1rem;
      margin: 0 .25rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    button[disabled] {
      opacity: .4;
      cursor: not-allowed;
    }
    button.off {
      background: var(--gray);
    }
    .material-symbols-outlined {
      font-size: 24px;
      vertical-align: middle;
    }
    #edit-zone .material-symbols-outlined {
      font-variation-settings: 'FILL' 1;
    }
    .same-content {
      display: block;
      margin-top: .5rem;
    }
    .knife-section {
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--pad);
      margin-bottom: 1rem;
    }
    .navigation {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      background: rgb(51, 57, 68);
      padding: 1rem;
      display: flex;
      justify-content: center;
      gap: 0.6rem;
      z-index: 100;
      flex-wrap: nowrap;
      overflow-x: auto;
      white-space: nowrap;
      margin: 20px 0;
      width: auto;
      max-width: 510px;
      border-radius: 18px;
      box-shadow: 0px 0px 5px #2f3138;
    }
    .preview-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .preview-item {
      text-align: center;
    }
    .preview-item img {
      width: 100%;
      max-width: 100%;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      cursor: pointer;
    }
    .preview-item span {
      display: block;
      font-size: .9rem;
      margin-top: .5rem;
    }
    .preview-description {
      text-align: center;
      font-size: .9rem;
      color: #666;
      margin-bottom: 1rem;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: .5rem;
    }
    .modal img {
      max-width: 90%;
      max-height: 85%;
      border-radius: var(--radius);
    }
    .modal span {
      color: #fff;
      font-size: 1rem;
    }
    #lang-toggle {
      display: none;
      margin: 0 auto 1rem;
      padding: .5rem 1rem;
      text-align: center;
    }
    #page-1.active #lang-toggle {
      display: block;
    }
    .knife-section p {
      margin: 11px 0px;
      color: #a5a5a5 !important;
    }
    div#page-1 {
      color: #4c4c4c;
    }
    .button-guide {
      background: #fff;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--pad);
      margin-bottom: 1rem;
    }
    .button-guide h3 {
      margin-bottom: 1rem;
      color: #000;
    }
    .button-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .button-item {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    .guide-button {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: .6rem;
      border-radius: var(--radius);
      cursor: default;
      font-weight: 600;
      font-size: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 40px;
    }
    .button-desc h4 {
      font-size: 1rem;
      margin-bottom: .25rem;
      color: #333;
    }
    .button-desc p {
      font-size: .9rem;
      color: #666;
      margin-bottom: .25rem;
    }
    .alert-content {
      background: #fff;
      padding: 1.5rem;
      border-radius: var(--radius);
      text-align: center;
      max-width: 90%;
      width: 400px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    .alert-content p {
      color: #333;
      font-size: 1rem;
      margin-bottom: 1rem;
    }
    #alert-close {
      background: var(--accent);
      color: #fff;
      padding: .5rem 1rem;
      border: none;
      border-radius: var(--radius);
      cursor: pointer;
      display: inline-block;
    }
    .disclaimer {
      background: #fff;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--pad);
      margin-bottom: 1rem;
    }
    .disclaimer h3 {
      margin-bottom: 1rem;
      color: #000;
    }
    .disclaimer p {
      font-size: .9rem;
      color: #666;
      line-height: 1.5;
    }
    @media (max-width: 600px) {
      .container {
        padding: var(--mpad);
      }
      .controls {
        flex-direction: column;
        align-items: flex-start;
        display: block;
      }
      .controls div {
        margin: 10px 0px;
      }
      .controls input[type="text"] {
        width: 100%;
        max-width: 250px;
      }
      .controls select[id^="weight-"] {
        width: 100%;
        max-width: 250px;
      }
      button {
        padding: .5rem;
        font-size: .9rem;
      }
      .material-symbols-outlined {
        font-size: 20px;
      }
      #lang-toggle {
        margin: 0 auto .5rem;
        padding: .4rem .8rem;
        font-size: .9rem;
      }
      .modal span {
        font-size: .9rem;
      }
      .button-guide {
        padding: .5rem;
      }
      .button-item {
        flex-direction: column;
        align-items: center;
        text-align: center;
      }
      .guide-button {
        padding: .5rem;
        min-width: 36px;
      }
      .button-desc h4 {
        font-size: .9rem;
      }
      .button-desc p {
        font-size: .8rem;
      }
      .disclaimer {
        padding: .5rem;
      }
      .disclaimer h3 {
        font-size: 1rem;
      }
      .disclaimer p {
        font-size: .8rem;
      }
    }
  </style>
</head>
<body>
  <h1 id="title">Knife Engraving Customizer</h1>
  <h3 id="subtitle">by <img src="kool-logo.png" alt="logo" style="width:50px;vertical-align:bottom;"></h3>
  <div class="container">
    <!-- Page 1: Knife Selection -->
    <div id="page-1" class="page section active">
      <button id="lang-toggle">中文</button>
      <h2 data-i18n="chooseKnives">Choose your items</h2>
      <div id="product-picker">
        <label class="product-option">
          <input type="checkbox" name="product" value="chef.jpg" data-thumb="chef-thumb.jpg" data-name="chef">
          <img src="chef-thumb.jpg" alt="Chef knife">
          <span data-i18n="chefKnife">Chef Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="santoku.jpg" data-thumb="santoku-thumb.jpg" data-name="santoku">
          <img src="santoku-thumb.jpg" alt="Santoku knife">
          <span data-i18n="santokuKnife">Santoku Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="bread.jpg" data-thumb="bread-thumb.jpg" data-name="bread">
          <img src="bread-thumb.jpg" alt="Bread knife">
          <span data-i18n="breadKnife">Bread Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="chopper.jpg" data-thumb="chopper-thumb.jpg" data-name="chopper">
          <img src="chopper-thumb.jpg" alt="Chopper knife">
          <span data-i18n="chopperKnife">Chopper Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="utility.jpg" data-thumb="utility-thumb.jpg" data-name="utility">
          <img src="utility-thumb.jpg" alt="Utility knife">
          <span data-i18n="utilityKnife">Utility Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="paring.jpg" data-thumb="paring-thumb.jpg" data-name="paring">
          <img src="paring-thumb.jpg" alt="Paring knife">
          <span data-i18n="paringKnife">Paring Knife</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="tongs.jpg" data-thumb="tongs-thumb.jpg" data-name="tongs">
          <img src="tongs-thumb.jpg" alt="Tongs">
          <span data-i18n="tongs">Tongs</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="scissors.jpg" data-thumb="scissors-thumb.jpg" data-name="scissors">
          <img src="scissors-thumb.jpg" alt="Scissors">
          <span data-i18n="scissors">Scissors</span>
        </label>
        <label class="product-option">
          <input type="checkbox" name="product" value="chopping-board.jpg" data-thumb="chopping-board-thumb.jpg" data-name="choppingBoard">
          <img src="chopping-board-thumb.jpg" alt="Chopping board">
          <span data-i18n="choppingBoard">Chopping Board</span>
        </label>
      </div>
      <div class="navigation">
        <button id="next-1"><span class="material-symbols-outlined">arrow_forward_ios</span></button>
      </div>
    </div>

    <!-- Page 2: Big Knives Customization -->
    <div id="page-2" class="page">
      <div id="big-knife-content"></div>
      <div class="navigation">
        <button id="back-2"><span class="material-symbols-outlined">arrow_back_ios_new</span></button>
        <button id="edit-zone"><span class="material-symbols-outlined">vignette</span></button>
        <button id="resize-controls"><span class="material-symbols-outlined">format_shapes</span></button>
        <button id="sync-fonts"><span class="material-symbols-outlined">format_size</span></button>
        <button id="auto-align"><span class="material-symbols-outlined">recenter</span></button>
        <button id="next-2"><span class="material-symbols-outlined">arrow_forward_ios</span></button>
      </div>
    </div>

    <!-- Page 3: Small Knives Customization -->
    <div id="page-3" class="page">
      <div id="small-knife-content"></div>
      <div class="navigation">
        <button id="back-3"><span class="material-symbols-outlined">arrow_back_ios_new</span></button>
        <button id="edit-zone"><span class="material-symbols-outlined">vignette</span></button>
        <button id="resize-controls"><span class="material-symbols-outlined">format_shapes</span></button>
        <button id="sync-fonts"><span class="material-symbols-outlined">format_size</span></button>
        <button id="auto-align"><span class="material-symbols-outlined">recenter</span></button>
        <button id="next-3"><span class="material-symbols-outlined">arrow_forward_ios</span></button>
      </div>
    </div>

    <!-- Page 4: Preview and Download -->
    <div id="page-4" class="page section">
      <h2 data-i18n="previewAllKnives">Preview All Items</h2>
      <div class="preview-description" data-i18n="previewDescription">Click any image to enlarge</div>
      <div id="preview-content" class="preview-list"></div>
      <div class="navigation">
        <button id="back-4"><span class="material-symbols-outlined">arrow_back_ios_new</span></button>
        <button id="download-all"><span class="material-symbols-outlined">download_2</span></button>
      </div>
    </div>

    <!-- Page 5: Non-Knife Items Customization -->
    <div id="page-5" class="page">
      <div id="other-content"></div>
      <div class="navigation">
        <button id="back-5"><span class="material-symbols-outlined">arrow_back_ios_new</span></button>
        <button id="edit-zone"><span class="material-symbols-outlined">vignette</span></button>
        <button id="resize-controls"><span class="material-symbols-outlined">format_shapes</span></button>
        <button id="sync-fonts"><span class="material-symbols-outlined">format_size</span></button>
        <button id="auto-align"><span class="material-symbols-outlined">recenter</span></button>
        <button id="next-5"><span class="material-symbols-outlined">arrow_forward_ios</span></button>
      </div>
    </div>

    <!-- Modal for Enlarged Image -->
    <div id="modal" class="modal">
      <img id="modal-image" src="" alt="Enlarged preview">
      <span data-i18n="modalClose">Click anywhere to close</span>
    </div>

    <div class="button-guide">
      <h3 data-i18n="buttonGuideTitle">How to Use the Controls</h3>
      <div class="button-list">
        <div class="button-item">
          <button class="guide-button"><span class="material-symbols-outlined">arrow_back_ios_new</span></button>
          <div class="button-desc">
            <h4 data-i18n="backCustomize"></h4>
            <p data-i18n="backCustomizeOn"></p>
            <p data-i18n="backCustomizeOff"></p>
          </div>
        </div>
        <div class="button-item">
          <button class="guide-button"><span class="material-symbols-outlined" style="font-variation-settings: 'FILL' 1">vignette</span></button>
          <div class="button-desc">
            <h4 data-i18n="editZoneGuide"></h4>
            <p data-i18n="editZoneOn"></p>
            <p data-i18n="editZoneOff"></p>
          </div>
        </div>
        <div class="button-item">
          <button class="guide-button"><span class="material-symbols-outlined">format_shapes</span></button>
          <div class="button-desc">
            <h4 data-i18n="resizeControlsGuide"></h4>
            <p data-i18n="resizeControlsOn"></p>
            <p data-i18n="resizeControlsOff"></p>
          </div>
        </div>
        <div class="button-item">
          <button class="guide-button"><span class="material-symbols-outlined">format_size</span></button>
          <div class="button-desc">
            <h4 data-i18n="syncFontsGuide"></h4>
            <p data-i18n="syncFontsOn"></p>
            <p data-i18n="syncFontsOff"></p>
          </div>
        </div>
        <div class="button-item">
          <button class="guide-button"><span class="material-symbols-outlined">recenter</span></button>
          <div class="button-desc">
            <h4 data-i18n="autoAlignGuide"></h4>
            <p data-i18n="autoAlignOn"></p>
            <p data-i18n="autoAlignOff"></p>
          </div>
        </div>
        <div class="button-item">
          <button class="guide-button" data-i18n="nextGuide"><span class="material-symbols-outlined">arrow_forward_ios</span></button>
          <div class="button-desc">
            <h4 data-i18n="backPreview"></h4>
            <p data-i18n="backPreviewOn"></p>
            <p data-i18n="backPreviewOff"></p>
          </div>
        </div>
        <div class="button-item">
          <button class="guide-button"><span class="material-symbols-outlined">download_2</span></button>
          <div class="button-desc">
            <h4 data-i18n="downloadGuide"></h4>
            <p data-i18n="downloadOn"></p>
            <p data-i18n="downloadOff"></p>
          </div>
        </div>
      </div>
    </div>
    <!-- Disclaimer -->
    <div class="disclaimer">
      <h3 data-i18n="disclaimerTitle">Disclaimer</h3>
      <p data-i18n="disclaimerText"></p>
    </div>
    <!-- Custom Alert Modal -->
    <div id="alert-modal" class="modal">
      <div class="alert-content">
        <p id="alert-message"></p>
        <button id="alert-close" data-i18n="close">Close</button>
      </div>
    </div>
  </div>

  <script>
    /* TRANSLATIONS */
    const translations = {
      en: {
        title: "Knife Engraving Customizer",
        subtitle: "by",
        subtitleAfter: "",
        next: "Next",
        back: "Back",
        preview: "Preview",
        previewAllKnives: "Preview All Items",
        previewDescription: "Click any image to enlarge",
        download: "Download",
        chefKnife: "Chef Knife",
        santokuKnife: "Santoku Knife",
        breadKnife: "Bread Knife",
        chopperKnife: "Chopper Knife",
        utilityKnife: "Utility Knife",
        paringKnife: "Paring Knife",
        textLabel: "Text:",
        textPlaceholder: "Enter engraving",
        fontLabel: "Font:",
        weightLabel: "Weight:",
        regular: "Regular",
        bold: "Bold",
        heavy: "Heavy",
        sameContentLabel: "Use same text for all",
        instructions: "• Drag text to move.<br>• Drag a corner to scale (desktop).<br>• Pinch to zoom and move text (mobile).",
        editZone: "Edit Zone",
        resizeControls: "Resize Controls",
        syncFonts: "Sync Fonts",
        autoAlignment: "Auto Align",
        loading: "Loading…",
        knife: "Knife",
        english: "English",
        chinese: "Chinese",
        modalClose: "Click anywhere to close",
        buttonGuideTitle: "How to Use the Controls",
        backCustomize: "Back",
        backCustomizeOn: "Returns to the previous page (e.g., item selection).",
        editZoneGuide: "Show Edit Area",
        editZoneOn: "ON: Displays the engraving area overlay to guide text placement.",
        editZoneOff: "OFF: Hides the engraving area overlay for a clearer view of the item.",
        resizeControlsGuide: "Show Resize Handles",
        resizeControlsOn: "ON: Shows corner handles to resize and reposition text by dragging.",
        resizeControlsOff: "OFF: Hides resize handles for a cleaner view while keeping text editable.",
        syncFontsGuide: "Sync Text Style",
        syncFontsOn: "ON: Applies the same font, weight, and size to all items on the same page.",
        syncFontsOff: "OFF: Allows different fonts, weights, and sizes for each item independently.",
        autoAlignGuide: "Auto Align Text",
        autoAlignOn: "Keeps text position aligned across all items on the same page for consistency.",
        autoAlignOff: "Allows independent text positioning for each item.",
        backPreview: "Next",
        backPreviewOn: "Advances to the next page (e.g., preview page).",
        downloadGuide: "Download All",
        downloadOn: "Downloads a ZIP file with preview and text-only images for all customized items.",
        noSelection: "Please select at least one item.",
        close: "Close",
        choppingBoard: "Chopping Board (Coming Soon)",
        tongs: "Tongs (Coming Soon)",
        scissors: "Scissors (Coming Soon)",
        chooseKnives: "Choose your items",
        disclaimerTitle: "Disclaimer",
        disclaimerText: `
          The Knife Engraving Customizer allows you to preview and design personalized engravings on selected products. Please note the following:<br>
          • <strong>Preview Accuracy</strong>: The previews generated are for visualization purposes only and may differ slightly from the final engraved product due to variations in materials, engraving techniques, or device display settings.<br>
          • <strong>Content Responsibility</strong>: You are responsible for ensuring that the text entered is appropriate, non-offensive, and complies with applicable laws. We reserve the right to reject any engraving requests that contain inappropriate or prohibited content.<br>
          • <strong>Font and Weight Limitations</strong>: Some fonts (e.g., Lobster, Chocolate Classical Sans, LXGW WenKai Mono TC) do not support bold (700) or heavy (900) weights and will default to their standard weight (400). Final engraving appearance may vary based on font and weight selection.<br>
          • <strong>Production Limitations</strong>: Engraving placement, size, and depth are subject to the physical constraints of the selected product and our engraving equipment. We will make reasonable efforts to match your design, but minor adjustments may be necessary.<br>
          • <strong>No Refunds for Customization</strong>: Due to the personalized nature of engraved products, orders are final and non-refundable unless the product is defective or the engraving significantly deviates from the approved design.<br>
          • <strong>Technical Issues</strong>: While we strive to ensure the tool functions correctly, we are not liable for errors caused by technical issues, such as browser compatibility or incorrect preview rendering.<br>
          By using this tool, you acknowledge and agree to these terms. For questions, contact our customer support.
        `
      },
      "zh-hk": {
        title: "刀具刻字定制器",
        subtitle: "由",
        subtitleAfter: "提供",
        next: "下一步",
        back: "返回",
        preview: "預覽",
        previewAllKnives: "預覽所有產品",
        previewDescription: "點擊任何圖片放大",
        download: "下載",
        chefKnife: "主廚刀",
        santokuKnife: "三德刀",
        breadKnife: "麵包刀",
        chopperKnife: "砍刀",
        utilityKnife: "多用途刀",
        paringKnife: "削皮刀",
        textLabel: "文字：",
        textPlaceholder: "輸入刻字",
        fontLabel: "字體：",
        weightLabel: "字重：",
        regular: "標準",
        bold: "粗體",
        heavy: "特粗",
        sameContentLabel: "所有產品使用相同文字",
        instructions: "• 拖動文字以移動。<br>• 拖動角落以縮放（桌面）。<br>• 捏合以縮放和移動文字（手機）。",
        editZone: "編輯區域",
        resizeControls: "調整控制",
        syncFonts: "同步字體",
        autoAlignment: "自動對齊",
        loading: "載入中…",
        knife: "刀",
        english: "英文",
        chinese: "中文",
        modalClose: "點擊任意位置關閉",
        buttonGuideTitle: "如何使用控制按鈕",
        backCustomize: "返回",
        backCustomizeOn: "返回上一頁（例如產品選擇）。",
        editZoneGuide: "顯示編輯區域",
        editZoneOn: "開：顯示刻字區域覆蓋，指引文字放置。",
        editZoneOff: "關：隱藏刻字區域覆蓋，以更清晰地查看產品。",
        resizeControlsGuide: "顯示調整手柄",
        resizeControlsOn: "開：顯示角落手柄，可拖動調整文字大小和位置。",
        resizeControlsOff: "關：隱藏調整手柄，保持文字可編輯但視圖更簡潔。",
        syncFontsGuide: "同步文字樣式",
        syncFontsOn: "開：將相同的字體、字重和大小應用於同一頁的所有產品。",
        syncFontsOff: "關：允許每份產品獨立使用不同的字體、字重和大小。",
        autoAlignGuide: "自動對齊文字",
        autoAlignOn: "開：保持同一組產品的文字位置對齊，確保一致性。",
        autoAlignOff: "關：允許每件產品的文字位置獨立調整。",
        backPreview: "下一步",
        backPreviewOn: "前往下一頁（例如預覽頁面）。",
        downloadGuide: "下載全部",
        downloadOn: "下載包含所有定制刀具預覽和純文字圖片的ZIP文件。",
        noSelection: "請至少選擇一件產品。",
        close: "關閉",
        choppingBoard: "砧板（即將推出）",
        tongs: "夾子（即將推出）",
        scissors: "剪刀（即將推出）",
        chooseKnives: "選擇你的產品",
        disclaimerTitle: "免責聲明",
        disclaimerText: `
          刀具刻字定制器允許您預覽和設計所選產品的個性化刻字。請注意以下事項：<br>
          • <strong>預覽準確性</strong>：生成的預覽僅供視覺參考，可能因材料、刻字技術或設備顯示設置的差異，與最終刻字產品略有不同。<br>
          • <strong>內容責任</strong>：您有責任確保輸入的文字適當、無冒犯性並符合適用法律。我們保留拒絕任何包含不當或禁止內容的刻字請求的權利。<br>
          • <strong>字體和字重限制</strong>：某些字體（例如Lobster、朱古力黑體、霞鶩文楷）不支持粗體（700）或特粗（900）字重，將默認為標準字重（400）。最終刻字外觀可能因字體和字重選擇而異。<br>
          • <strong>生產限制</strong>：刻字的位置、大小和深度受所選產品和我們刻字設備的物理限制。我們會盡合理努力匹配您的設計，但可能需要輕微調整。<br>
          • <strong>定制產品無退貨</strong>：由於刻字產品的個性化特性，除非產品有缺陷或刻字與批准的設計顯著不符，否則訂單為最終確認且不可退貨。<br>          
          • <strong>技術問題</strong>：雖然我們努力確保工具正常運行，但我們對因技術問題（例如瀏覽器兼容性或預覽渲染錯誤）導致的錯誤不承擔責任。<br>
          使用本工具即表示您認可並同意這些條款。如有疑問，請聯繫我們的客戶支持。
        `
      }
    };

    /* DOM ELEMENTS */
    const productPicker = document.getElementById('product-picker');
    const bigKnifeContent = document.getElementById('big-knife-content');
    const smallKnifeContent = document.getElementById('small-knife-content');
    const otherContent = document.getElementById('other-content');
    const previewContent = document.getElementById('preview-content');
    const modal = document.getElementById('modal');
    const modalImage = document.getElementById('modal-image');
    const langToggle = document.getElementById('lang-toggle');
    const nextBtn1 = document.getElementById('next-1');
    const backBtn2 = document.getElementById('back-2');
    const backBtn3 = document.getElementById('back-3');
    const backBtn4 = document.getElementById('back-4');
    const backBtn5 = document.getElementById('back-5');
    const nextBtn2 = document.getElementById('next-2');
    const nextBtn3 = document.getElementById('next-3');
    const nextBtn5 = document.getElementById('next-5');
    const downloadBtn = document.getElementById('download-all');
    const editZoneBtn = document.querySelectorAll('#edit-zone');
    const resizeControlsBtn = document.querySelectorAll('#resize-controls');
    const syncFontsBtn = document.querySelectorAll('#sync-fonts');
    const autoAlignBtn = document.querySelectorAll('#auto-align');
    const alertModal = document.getElementById('alert-modal');
    const alertMessage = document.getElementById('alert-message');
    const alertClose = document.getElementById('alert-close');

    /* STATE */
    const state = {};
    const knives = {
      big: ['chef', 'santoku', 'bread', 'chopper'],
      small: ['utility', 'paring'],
      others: ['tongs', 'scissors', 'choppingBoard']
    };
    let currentPage = 1;
    let currentLang = 'en';
    let sameContent = false;
    let sharedText = '';
    let showEditZone = false;
    let showResizeControls = false;
    let syncFonts = false;
    let autoAlign = false;
    let firstSelectedKnife = null;
    let lastBigKnifeFont = 'Montserrat';
    const lastAdjusted = { big: null, small: null, others: null };

    /* UTILITY FUNCTIONS */
    function translatePage() {
      document.querySelectorAll('[data-i18n]').forEach(elem => {
        const key = elem.getAttribute('data-i18n');
        if (elem.tagName === 'INPUT' && elem.type === 'text') {
          elem.placeholder = translations[currentLang][key] || elem.placeholder;
        } else if (elem.tagName === 'BUTTON' && !elem.querySelector('.material-symbols-outlined')) {
          elem.textContent = translations[currentLang][key] || elem.textContent;
        } else {
          elem.innerHTML = translations[currentLang][key] || elem.innerHTML;
        }
      });
      document.title = translations[currentLang].title;
      document.getElementById('title').textContent = translations[currentLang].title;
      document.getElementById('subtitle').innerHTML = `${translations[currentLang].subtitle} <img src="kool-logo.png" alt="logo" style="width:50px;vertical-align:bottom;"> ${translations[currentLang].subtitleAfter}`;
      langToggle.textContent = currentLang === 'en' ? '中文' : 'English';
      Object.keys(state).forEach(knife => {
        const select = state[knife].fontSel;
        const defaultFont = currentLang === 'zh-hk' && select.dataset.default ? select.dataset.default : 'Montserrat';
        select.value = knives.big.includes(knife) ? lastBigKnifeFont : defaultFont;
        state[knife].baseDims = measureText(state[knife].fCtx, state[knife].textInput.value, state[knife].baseFont, select.value, state[knife].fontWeight);
        invalidateTextCache(knife);
        if (!state[knife].pendingDraw) {
          state[knife].pendingDraw = true;
          requestAnimationFrame(() => draw(knife));
        }
      });
    }

    function showPage(pageNum) {
      document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
      document.getElementById(`page-${pageNum}`).classList.add('active');
      currentPage = pageNum;
      if (pageNum === 4) generatePreviews();
    }

    function showAlert(messageKey) {
      alertMessage.textContent = translations[currentLang][messageKey] || messageKey;
      alertModal.style.display = 'flex';
    }

    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.src = src;
        img.onload = () => resolve(img);
        img.onerror = reject;
      });
    }

    function measureText(ctx, text, fontSize, font, weight = '400') {
      const unsupportedFonts = ['Lobster', "'Chocolate Classical Sans',sans-serif", "'LXGW WenKai Mono TC',monospace"];
      const effectiveWeight = unsupportedFonts.includes(font) && weight !== '400' ? '400' : weight;
      ctx.font = `${effectiveWeight} ${fontSize}px ${font}`;
      return { w: ctx.measureText(text).width, h: fontSize };
    }

    function fitInBox(canvas, img, wrapper) {
      const maxWidth = wrapper.clientWidth;
      const maxHeight = window.innerHeight * 0.5;
      const aspect = img.naturalWidth / img.naturalHeight;
      let width = img.naturalWidth;
      let height = img.naturalHeight;
      if (width > maxWidth) {
        width = maxWidth;
        height = width / aspect;
      }
      if (height > maxHeight) {
        height = maxHeight;
        width = height * aspect;
      }
      canvas.width = width;
      canvas.height = height;
    }

    function invalidateTextCache(knife) {
      state[knife].textCacheValid = false;
    }

    function invalidateCache(knife) {
      state[knife].cacheValid = false;
      state[knife].textCacheValid = false;
    }

    function createCanvasSection(knife) {
      const showSameContent = knife === firstSelectedKnife;
      const section = document.createElement('div');
      section.className = 'knife-section';
      section.innerHTML = `
        <h3 data-i18n="${knives.big.includes(knife) || knives.small.includes(knife) ? knife + 'Knife' : knife}">${translations[currentLang][knives.big.includes(knife) || knives.small.includes(knife) ? knife + 'Knife' : knife]}</h3>
        <div class="controls">
          <div>
            <label for="text-${knife}" data-i18n="textLabel">${translations[currentLang].textLabel}</label>
            <input type="text" id="text-${knife}" placeholder="${translations[currentLang].textPlaceholder}">
          </div>
          <div>
            <label for="font-${knife}" data-i18n="fontLabel">${translations[currentLang].fontLabel}</label>
            <select id="font-${knife}" ${currentLang === 'zh-hk' ? 'data-default="Noto Sans HK"' : ''}>
              <optgroup label="${translations[currentLang].english}">
                <option value="Montserrat">Montserrat</option>
                <option value="Roboto">Roboto</option>
                <option value="Lobster">Lobster</option>
                <option value="'Times New Roman',serif">Times New Roman</option>
                <option value="'Courier New',monospace">Courier New</option>
                <option value="Arial,sans-serif">Arial</option>
              </optgroup>
              <optgroup label="${translations[currentLang].chinese}">
                <option value="'Chocolate Classical Sans',sans-serif">朱古力黑體</option>
                <option value="'LXGW WenKai Mono TC',monospace">霞鶩文楷</option>
                <option value="'Noto Sans HK',sans-serif">思源黑體</option>
                <option value="'Noto Serif TC',serif">思源宋體</option>
              </optgroup>
            </select>
          </div>
          <div>
            <label for="weight-${knife}" data-i18n="weightLabel">${translations[currentLang].weightLabel}</label>
            <select id="weight-${knife}">
              <option value="400">${translations[currentLang].regular}</option>
              <option value="700">${translations[currentLang].bold}</option>
              <option value="900">${translations[currentLang].heavy}</option>
            </select>
          </div>
        </div>
        ${showSameContent ? `
          <div class="same-content">
            <input type="checkbox" id="same-content-${knife}" ${sameContent ? 'checked' : ''}>
            <label for="same-content-${knife}" data-i18n="sameContentLabel">${translations[currentLang].sameContentLabel}</label>
          </div>
        ` : ''}
        <p style="font-size:.8rem;color:#666;margin-top:.5rem;" data-i18n="instructions">
          ${translations[currentLang].instructions}
        </p>
        <div class="canvas-wrapper" id="wrapper-${knife}">
          <canvas id="canvas-${knife}"></canvas>
          <div class="loading-overlay" id="overlay-${knife}" data-i18n="loading">${translations[currentLang].loading}</div>
          <div class="bbox" id="bbox-${knife}">
            <div class="handle" data-handle="nw"></div>
            <div class="handle" data-handle="ne"></div>
            <div class="handle" data-handle="sw"></div>
            <div class="handle" data-handle="se"></div>
          </div>
        </div>
      `;
      if (knives.big.includes(knife)) {
        bigKnifeContent.appendChild(section);
      } else if (knives.small.includes(knife)) {
        smallKnifeContent.appendChild(section);
      } else if (knives.others.includes(knife)) {
        otherContent.appendChild(section);
      }

      state[knife] = {
        img: null,
        overlay: null,
        baseFont: knives.big.includes(knife) ? 150 : knives.small.includes(knife) ? 100 : 120,
        textScale: 1,
        fontWeight: '400',
        baseDims: { w: 0, h: 0 },
        textRightX: 0,
        pos: { y: 0 },
        boxVisible: showResizeControls,
        dragging: false,
        dragStart: {},
        resizing: false,
        resizeStart: {},
        pointers: {},
        pinch: false,
        pinchStart: {},
        view: document.getElementById(`canvas-${knife}`),
        vCtx: document.getElementById(`canvas-${knife}`).getContext('2d'),
        full: document.createElement('canvas'),
        fCtx: document.createElement('canvas').getContext('2d'),
        wrapper: document.getElementById(`wrapper-${knife}`),
        overlayEl: document.getElementById(`overlay-${knife}`),
        bbox: document.getElementById(`bbox-${knife}`),
        textInput: document.getElementById(`text-${knife}`),
        fontSel: document.getElementById(`font-${knife}`),
        weightSel: document.getElementById(`weight-${knife}`),
        sameContentChk: showSameContent ? document.getElementById(`same-content-${knife}`) : null,
        cacheCanvas: document.createElement('canvas'),
        cacheCtx: document.createElement('canvas').getContext('2d'),
        textCacheCanvas: document.createElement('canvas'),
        textCacheCtx: document.createElement('canvas').getContext('2d'),
        previewCanvas: document.createElement('canvas'),
        cacheValid: false,
        textCacheValid: false,
        pendingDraw: false
      };
      state[knife].full.width = 0;
      state[knife].full.height = 0;
      state[knife].fCtx = state[knife].full.getContext('2d');
      state[knife].cacheCanvas.width = 0;
      state[knife].cacheCanvas.height = 0;
      state[knife].cacheCtx = state[knife].cacheCanvas.getContext('2d');
      state[knife].textCacheCanvas.width = 0;
      state[knife].textCacheCanvas.height = 0;
      state[knife].textCacheCtx = state[knife].textCacheCanvas.getContext('2d');
      state[knife].previewCanvas.width = 0;
      state[knife].previewCanvas.height = 0;
    }

    function draw(knife) {
      const s = state[knife];
      if (!s.img || s.full.width === 0 || s.full.height === 0) return;

      const textX = s.textRightX;

      if (!s.cacheValid) {
        s.cacheCanvas.width = s.full.width;
        s.cacheCanvas.height = s.full.height;
        if (s.cacheCanvas.width === 0 || s.cacheCanvas.height === 0) return;
        s.cacheCtx.clearRect(0, 0, s.full.width, s.full.height);
        s.cacheCtx.drawImage(s.img, 0, 0);
        if (showEditZone && s.overlay) {
          s.cacheCtx.drawImage(s.overlay, 0, 0, s.full.width, s.full.height);
        }
        s.cacheValid = true;
      }

      if (!s.textCacheValid) {
        s.textCacheCanvas.width = s.full.width;
        s.textCacheCanvas.height = s.full.height;
        if (s.textCacheCanvas.width === 0 || s.textCacheCanvas.height === 0) return;
        s.textCacheCtx.clearRect(0, 0, s.full.width, s.full.height);
        if (s.textInput.value) {
          const unsupportedFonts = ['Lobster', "'Chocolate Classical Sans',sans-serif", "'LXGW WenKai Mono TC',monospace"];
          const effectiveWeight = unsupportedFonts.includes(s.fontSel.value) && s.fontWeight !== '400' ? '400' : s.fontWeight;
          s.textCacheCtx.font = `${effectiveWeight} ${s.baseFont * s.textScale}px ${s.fontSel.value}`;
          s.textCacheCtx.fillStyle = '#000';
          s.textCacheCtx.textBaseline = 'top';
          s.textCacheCtx.textAlign = 'right';
          s.textCacheCtx.fillText(s.textInput.value, textX, s.pos.y);
        }
        s.textCacheValid = true;
      }

      s.fCtx.clearRect(0, 0, s.full.width, s.full.height);
      s.fCtx.drawImage(s.cacheCanvas, 0, 0);
      s.fCtx.drawImage(s.textCacheCanvas, 0, 0);

      const scale = s.view.width / s.full.width;
      s.vCtx.imageSmoothingEnabled = true;
      s.vCtx.imageSmoothingQuality = 'high';
      s.vCtx.setTransform(scale, 0, 0, scale, 0, 0);
      s.vCtx.clearRect(0, 0, s.full.width, s.full.height);
      s.vCtx.drawImage(s.cacheCanvas, 0, 0);
      s.vCtx.drawImage(s.textCacheCanvas, 0, 0);
      s.vCtx.setTransform(1, 0, 0, 1, 0, 0);

      const dx = s.view.width / s.full.width;
      const dy = s.view.height / s.full.height;
      if (s.boxVisible && s.textInput.value) {
        s.bbox.style.display = 'block';
        s.bbox.style.width = (s.baseDims.w * s.textScale * dx) + 'px';
        s.bbox.style.height = (s.baseDims.h * s.textScale * dy) + 'px';
        s.bbox.style.left = ((textX - s.baseDims.w * s.textScale) * dx) + 'px';
        s.bbox.style.top = (s.pos.y * dy) + 'px';
      } else {
        s.bbox.style.display = 'none';
      }
      s.pendingDraw = false;
    }

    function syncFontAndText(knife) {
      if (!syncFonts) return;
      const refState = state[knife];
      const fontFamily = refState.fontSel.value;
      const effectiveFontSize = refState.baseFont * refState.textScale;
      const fontWeight = refState.weightSel.value;
      const isBigKnife = knives.big.includes(knife);
      const isSmallKnife = knives.small.includes(knife);
      const isOtherItem = knives.others.includes(knife);
      Object.keys(state).forEach(k => {
        if (k !== knife &&
            ((isBigKnife && knives.big.includes(k)) ||
             (isSmallKnife && knives.small.includes(k)) ||
             (isOtherItem && knives.others.includes(k)))) {
          state[k].fontSel.value = fontFamily;
          state[k].weightSel.value = fontWeight;
          state[k].baseFont = effectiveFontSize;
          state[k].textScale = 1;
          state[k].baseDims = measureText(state[k].fCtx, state[k].textInput.value, state[k].baseFont, state[k].fontSel.value, state[k].weightSel.value);
          invalidateTextCache(k);
          if (!state[k].pendingDraw) {
            state[k].pendingDraw = true;
            requestAnimationFrame(() => draw(k));
          }
        }
      });
      if (isBigKnife) {
        lastBigKnifeFont = fontFamily;
      }
    }

    function syncPosition(knife) {
      if (!autoAlign) return;
      const refState = state[knife];
      const isBigKnife = knives.big.includes(knife);
      const isSmallKnife = knives.small.includes(knife);
      const isOtherItem = knives.others.includes(knife);
      Object.keys(state).forEach(k => {
        if (k !== knife &&
            ((isBigKnife && knives.big.includes(k)) ||
             (isSmallKnife && knives.small.includes(k)) ||
             (isOtherItem && knives.others.includes(k)))) {
          state[k].textRightX = refState.textRightX;
          state[k].pos.y = refState.pos.y;
          invalidateTextCache(k);
          if (!state[k].pendingDraw) {
            state[k].pendingDraw = true;
            requestAnimationFrame(() => draw(k));
          }
        }
      });
    }

    function centerText(knife) {
      const s = state[knife];
      s.textRightX = s.full.width / 2;
      s.pos.y = s.full.height / 2;
      s.textScale = 1;
      s.baseFont = knives.big.includes(knife) ? 150 : knives.small.includes(knife) ? 100 : 120;
      s.baseDims = measureText(s.fCtx, s.textInput.value, s.baseFont, s.fontSel.value, s.fontWeight);
      invalidateTextCache(knife);
      if (!s.pendingDraw) {
        s.pendingDraw = true;
        requestAnimationFrame(() => draw(knife));
      }
      syncPosition(knife);
    }

    async function generatePreviews() {
      previewContent.innerHTML = '';
      for (const knife of Object.keys(state)) {
        const s = state[knife];
        s.previewCanvas.width = s.full.width;
        s.previewCanvas.height = s.full.height;
        const ctx = s.previewCanvas.getContext('2d');
        ctx.drawImage(s.img, 0, 0);
        if (s.textInput.value) {
          const unsupportedFonts = ['Lobster', "'Chocolate Classical Sans',sans-serif", "'LXGW WenKai Mono TC',monospace"];
          const effectiveWeight = unsupportedFonts.includes(s.fontSel.value) && s.fontWeight !== '400' ? '400' : s.fontWeight;
          ctx.font = `${effectiveWeight} ${s.baseFont * s.textScale}px ${s.fontSel.value}`;
          ctx.fillStyle = '#000';
          ctx.textBaseline = 'top';
          ctx.textAlign = 'right';
          ctx.fillText(s.textInput.value, s.textRightX, s.pos.y);
        }
        const previewUrl = s.previewCanvas.toDataURL('image/png');
        const div = document.createElement('div');
        div.className = 'preview-item';
        div.innerHTML = `
          <img src="${previewUrl}" alt="${knife} preview" data-knife="${knife}">
          <span data-i18n="${knives.big.includes(knife) || knives.small.includes(knife) ? knife + 'Knife' : knife}">${translations[currentLang][knives.big.includes(knife) || knives.small.includes(knife) ? knife + 'Knife' : knife]}</span>
        `;
        previewContent.appendChild(div);
      }
      previewContent.querySelectorAll('img').forEach(img => {
        img.addEventListener('click', () => {
          modalImage.src = img.src;
          modal.style.display = 'flex';
        });
      });
    }

    async function initializeKnife(knife) {
      createCanvasSection(knife);
      const s = state[knife];
      s.overlayEl.style.visibility = 'visible';
      s.img = await loadImage(
        productPicker.querySelector(`input[data-name="${knife}"]`).value
      );
      try {
        s.overlay = await loadImage(`${knife}-overlay.png`);
      } catch (e) {
        console.warn(`Overlay image for ${knife} not found`);
        s.overlay = null;
      }
      s.full.width = s.img.naturalWidth;
      s.full.height = s.img.naturalHeight;
      s.textRightX = s.full.width / 2;
      s.pos.y = s.full.height / 2;
      s.cacheCanvas.width = s.full.width;
      s.cacheCanvas.height = s.full.height;
      s.textCacheCanvas.width = s.full.width;
      s.textCacheCanvas.height = s.full.height;
      s.previewCanvas.width = s.full.width;
      s.previewCanvas.height = s.full.height;
      fitInBox(s.view, s.img, s.wrapper);
      const isBigKnife = knives.big.includes(knife);
      s.fontSel.value = isBigKnife ? lastBigKnifeFont : lastBigKnifeFont;
      s.baseDims = { w: 0, h: s.baseFont };

      if (sameContent && sharedText) {
        s.textInput.value = sharedText;
        s.baseDims = measureText(s.fCtx, s.textInput.value, s.baseFont, s.fontSel.value, s.fontWeight);
      }

      await document.fonts.load(`${s.fontWeight} ${s.baseFont}px ${s.fontSel.value}`);
      if (s.textInput.value) {
        s.baseDims = measureText(s.fCtx, s.textInput.value, s.baseFont, s.fontSel.value, s.fontWeight);
      }
      s.overlayEl.style.visibility = 'hidden';
      if (!s.pendingDraw) {
        s.pendingDraw = true;
        requestAnimationFrame(() => draw(knife));
      }

      s.textInput.addEventListener('input', () => {
        if (sameContent) {
          sharedText = s.textInput.value;
          Object.keys(state).forEach(k => {
            state[k].textInput.value = sharedText;
            state[k].baseDims = measureText(state[k].fCtx, state[k].textInput.value, state[k].baseFont, state[k].fontSel.value, state[k].fontWeight);
            invalidateTextCache(k);
            if (!state[k].pendingDraw) {
              state[k].pendingDraw = true;
              requestAnimationFrame(() => draw(k));
            }
          });
        } else {
          s.baseDims = measureText(s.fCtx, s.textInput.value, s.baseFont, s.fontSel.value, s.fontWeight);
          invalidateTextCache(knife);
          if (!s.pendingDraw) {
            s.pendingDraw = true;
            requestAnimationFrame(() => draw(knife));
          }
        }
        lastAdjusted[knives.big.includes(knife) ? 'big' : knives.small.includes(knife) ? 'small' : 'others'] = knife;
      });

      s.fontSel.addEventListener('input', () => {
        document.fonts.load(`${s.fontWeight} ${s.baseFont}px ${s.fontSel.value}`).then(() => {
          s.baseDims = measureText(s.fCtx, s.textInput.value, s.baseFont, s.fontSel.value, s.fontWeight);
          invalidateTextCache(knife);
          if (!s.pendingDraw) {
            s.pendingDraw = true;
            requestAnimationFrame(() => draw(knife));
          }
          syncFontAndText(knife);
          lastAdjusted[knives.big.includes(knife) ? 'big' : knives.small.includes(knife) ? 'small' : 'others'] = knife;
        });
      });

      s.weightSel.addEventListener('input', () => {
        document.fonts.load(`${s.weightSel.value} ${s.baseFont}px ${s.fontSel.value}`).then(() => {
          s.fontWeight = s.weightSel.value;
          s.baseDims = measureText(s.fCtx, s.textInput.value, s.baseFont, s.fontSel.value, s.fontWeight);
          invalidateTextCache(knife);
          if (!s.pendingDraw) {
            s.pendingDraw = true;
            requestAnimationFrame(() => draw(knife));
          }
          syncFontAndText(knife);
          lastAdjusted[knives.big.includes(knife) ? 'big' : knives.small.includes(knife) ? 'small' : 'others'] = knife;
        });
      });

      if (s.sameContentChk) {
        s.sameContentChk.addEventListener('change', () => {
          sameContent = s.sameContentChk.checked;
          if (sameContent) {
            sharedText = s.textInput.value;
            Object.keys(state).forEach(k => {
              state[k].textInput.value = sharedText;
              state[k].baseDims = measureText(state[k].fCtx, state[k].textInput.value, state[k].baseFont, state[k].fontSel.value, state[k].fontWeight);
              invalidateTextCache(k);
              if (!state[k].pendingDraw) {
                state[k].pendingDraw = true;
                requestAnimationFrame(() => draw(k));
              }
            });
          } else {
            sharedText = '';
          }
        });
      }

      s.view.addEventListener('pointerdown', e => {
        if (!s.boxVisible) return;
        e.preventDefault();
        const rect = s.view.getBoundingClientRect();
        const scaleX = s.full.width / s.view.width;
        const scaleY = s.full.height / s.view.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        const textLeft = s.textRightX - s.baseDims.w * s.textScale;
        if (x >= textLeft && x <= s.textRightX && y >= s.pos.y && y <= s.pos.y + s.baseDims.h * s.textScale) {
          s.dragging = true;
          s.dragStart = { x: x - s.textRightX, y: y - s.pos.y };
          s.pointers[e.pointerId] = { x, y };
          s.view.setPointerCapture(e.pointerId);
        }
      });

      s.bbox.addEventListener('pointerdown', e => {
        if (!s.boxVisible) return;
        const handle = e.target.dataset.handle;
        if (handle) {
          e.preventDefault();
          e.stopPropagation();
          s.resizing = handle;
          const rect = s.view.getBoundingClientRect();
          s.resizeStart = {
            x: (e.clientX - rect.left) * (s.full.width / s.view.width),
            y: (e.clientY - rect.top) * (s.full.height / s.view.height),
            scale: s.textScale,
            rightX: s.textRightX,
            yPos: s.pos.y
          };
          s.view.setPointerCapture(e.pointerId);
        }
      });

      s.view.addEventListener('pointermove', e => {
        const rect = s.view.getBoundingClientRect();
        const scaleX = s.full.width / s.view.width;
        const scaleY = s.full.height / s.view.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        s.pointers[e.pointerId] = { x, y };

        if (s.dragging) {
          s.textRightX = x - s.dragStart.x;
          s.pos.y = y - s.dragStart.y;
          invalidateTextCache(knife);
          if (!s.pendingDraw) {
            s.pendingDraw = true;
            requestAnimationFrame(() => draw(knife));
          }
          syncPosition(knife);
          lastAdjusted[knives.big.includes(knife) ? 'big' : knives.small.includes(knife) ? 'small' : 'others'] = knife;
        } else if (s.resizing) {
          const dx = x - s.resizeStart.x;
          const dy = y - s.resizeStart.y;
          let newScale = s.resizeStart.scale;
          if (s.resizing === 'se' || s.resizing === 'ne') {
            newScale = s.resizeStart.scale + dx / s.baseDims.w;
          } else {
            newScale = s.resizeStart.scale - dx / s.baseDims.w;
          }
          if (s.resizing === 'ne' || s.resizing === 'sw') {
            newScale = s.resizeStart.scale - dy / s.baseDims.h;
          } else {
            newScale = s.resizeStart.scale + dy / s.baseDims.h;
          }
          s.textScale = Math.max(0.1, Math.min(newScale, 5));
          s.textRightX = s.resizeStart.rightX;
          s.pos.y = s.resizeStart.yPos;
          invalidateTextCache(knife);
          if (!s.pendingDraw) {
            s.pendingDraw = true;
            requestAnimationFrame(() => draw(knife));
          }
          syncFontAndText(knife);
          lastAdjusted[knives.big.includes(knife) ? 'big' : knives.small.includes(knife) ? 'small' : 'others'] = knife;
        } else if (Object.keys(s.pointers).length === 2) {
          const [p1, p2] = Object.values(s.pointers);
          const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
          if (!s.pinch) {
            s.pinch = true;
            s.pinchStart = {
              dist,
              scale: s.textScale,
              rightX: s.textRightX,
              yPos: s.pos.y,
              centerX: (p1.x + p2.x) / 2,
              centerY: (p1.y + p2.y) / 2
            };
          } else {
            const scaleFactor = dist / s.pinchStart.dist;
            s.textScale = Math.max(0.1, Math.min(s.pinchStart.scale * scaleFactor, 5));
            s.textRightX = s.pinchStart.rightX + (x - s.pinchStart.centerX);
            s.pos.y = s.pinchStart.yPos + (y - s.pinchStart.centerY);
            invalidateTextCache(knife);
            if (!s.pendingDraw) {
              s.pendingDraw = true;
              requestAnimationFrame(() => draw(knife));
            }
            syncFontAndText(knife);
            syncPosition(knife);
            lastAdjusted[knives.big.includes(knife) ? 'big' : knives.small.includes(knife) ? 'small' : 'others'] = knife;
          }
        }
      });

      s.view.addEventListener('pointerup', e => {
        s.dragging = false;
        s.resizing = false;
        s.pinch = false;
        delete s.pointers[e.pointerId];
        s.view.releasePointerCapture(e.pointerId);
      });

      s.view.addEventListener('pointercancel', e => {
        s.dragging = false;
        s.resizing = false;
        s.pinch = false;
        delete s.pointers[e.pointerId];
        s.view.releasePointerCapture(e.pointerId);
      });

      window.addEventListener('resize', () => {
        fitInBox(s.view, s.img, s.wrapper);
        if (!s.pendingDraw) {
          s.pendingDraw = true;
          requestAnimationFrame(() => draw(knife));
        }
      });
    }

    /* EVENT LISTENERS */
    langToggle.addEventListener('click', () => {
      currentLang = currentLang === 'en' ? 'zh-hk' : 'en';
      translatePage();
    });

    nextBtn1.addEventListener('click', () => {
      const selected = Array.from(productPicker.querySelectorAll('input:checked')).map(input => input.dataset.name);
      if (selected.length === 0) {
        showAlert('noSelection');
        return;
      }
      bigKnifeContent.innerHTML = '';
      smallKnifeContent.innerHTML = '';
      otherContent.innerHTML = '';
      firstSelectedKnife = selected[0];
      selected.forEach(knife => initializeKnife(knife));
      const hasBigKnives = selected.some(k => knives.big.includes(k));
      const hasSmallKnives = selected.some(k => knives.small.includes(k));
      const hasOtherItems = selected.some(k => knives.others.includes(k));
      if (hasBigKnives) {
        showPage(2);
      } else if (hasSmallKnives) {
        showPage(3);
      } else if (hasOtherItems) {
        showPage(5);
      }
    });

    backBtn2.addEventListener('click', () => showPage(1));
    backBtn3.addEventListener('click', () => {
      const hasBigKnives = Object.keys(state).some(k => knives.big.includes(k));
      showPage(hasBigKnives ? 2 : 1);
    });
    backBtn4.addEventListener('click', () => {
      const hasOtherItems = Object.keys(state).some(k => knives.others.includes(k));
      const hasSmallKnives = Object.keys(state).some(k => knives.small.includes(k));
      showPage(hasOtherItems ? 5 : hasSmallKnives ? 3 : 2);
    });
    backBtn5.addEventListener('click', () => {
      const hasSmallKnives = Object.keys(state).some(k => knives.small.includes(k));
      showPage(hasSmallKnives ? 3 : 2);
    });

    nextBtn2.addEventListener('click', () => {
      const hasSmallKnives = Object.keys(state).some(k => knives.small.includes(k));
      showPage(hasSmallKnives ? 3 : 5);
    });
    nextBtn3.addEventListener('click', () => showPage(5));
    nextBtn5.addEventListener('click', () => showPage(4));

    editZoneBtn.forEach(btn => {
      btn.addEventListener('click', () => {
        showEditZone = !showEditZone;
        btn.classList.toggle('off', !showEditZone);
        Object.keys(state).forEach(knife => {
          invalidateCache(knife);
          if (!state[knife].pendingDraw) {
            state[knife].pendingDraw = true;
            requestAnimationFrame(() => draw(knife));
          }
        });
      });
    });

    resizeControlsBtn.forEach(btn => {
      btn.addEventListener('click', () => {
        showResizeControls = !showResizeControls;
        btn.classList.toggle('off', !showResizeControls);
        Object.keys(state).forEach(knife => {
          state[knife].boxVisible = showResizeControls;
          if (!state[knife].pendingDraw) {
            state[knife].pendingDraw = true;
            requestAnimationFrame(() => draw(knife));
          }
        });
      });
    });

    syncFontsBtn.forEach(btn => {
      btn.addEventListener('click', () => {
        syncFonts = !syncFonts;
        btn.classList.toggle('off', !syncFonts);
        if (syncFonts) {
          const group = currentPage === 2 ? 'big' : currentPage === 3 ? 'small' : 'others';
          const refKnife = lastAdjusted[group] || Object.keys(state).find(k => knives[group].includes(k));
          if (refKnife) syncFontAndText(refKnife);
        }
      });
    });

    autoAlignBtn.forEach(btn => {
      btn.addEventListener('click', () => {
        autoAlign = !autoAlign;
        btn.classList.toggle('off', !autoAlign);
        if (autoAlign) {
          const group = currentPage === 2 ? 'big' : currentPage === 3 ? 'small' : 'others';
          const refKnife = lastAdjusted[group] || Object.keys(state).find(k => knives[group].includes(k));
          if (refKnife) syncPosition(refKnife);
        }
      });
    });

    downloadBtn.addEventListener('click', async () => {
      const zip = new JSZip();
      for (const knife of Object.keys(state)) {
        const s = state[knife];
        const previewBlob = await new Promise(r => s.previewCanvas.toBlob(r));
        zip.file(`${knife}-preview.png`, previewBlob);

        const t = document.createElement('canvas');
        t.width = s.full.width;
        t.height = s.full.height;
        const tCtx = t.getContext('2d');
        const unsupportedFonts = ['Lobster', "'Chocolate Classical Sans',sans-serif", "'LXGW WenKai Mono TC',monospace"];
        const effectiveWeight = unsupportedFonts.includes(s.fontSel.value) && s.fontWeight !== '400' ? '400' : s.fontWeight;
        tCtx.font = `${effectiveWeight} ${s.baseFont * s.textScale}px ${s.fontSel.value}`;
        tCtx.fillStyle = '#000';
        tCtx.textBaseline = 'top';
        tCtx.textAlign = 'right';
        tCtx.fillText(s.textInput.value, s.textRightX, s.pos.y);
        const textBlob = await new Promise(r => t.toBlob(r));
        zip.file(`${knife}-text-only.png`, textBlob);
      }

      const zipBlob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(zipBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'knife-engravings.zip';
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        URL.revokeObjectURL(url);
        a.remove();
      }, 100);
    });

    modal.addEventListener('click', () => {
      modal.style.display = 'none';
    });

    alertClose.addEventListener('click', () => {
      alertModal.style.display = 'none';
    });

    translatePage();
  </script>
</body>
</html>
